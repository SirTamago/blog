[{"path":"/2024/05/23/微机原理上机实验相关/","content":"本文内容基于微机原理老师发的 2024年微机原理上机实验要求 重要的资源： 微机原理与接口技术(钱晓捷版)课后习题答案 实验任务1：熟悉DOS环境、熟悉汇编语言的开发过程和数据表达、变量定义及属性1. 熟悉进入和退出32位控制台和16位DOS环境的方法。2. 熟悉汇编语言的开发过程，实现教材例题2-1程序。 eg0201.asm1234567891011;eg0201.asm include io32.inc .datamsg byte &#x27;Hello,Assembly!&#x27;,13,10,0 .codestart: mov eax,offset msg call dispmsg exit 0 end start 3. 掌握数据寻址方式，上机实现教材中的例题2-2程序。 eg0202.asm123456789101112131415161718192021;eg0202.asminclude io32.inc.datacount dword 12345678h,9abcdef0h,0,0,3721h.codestart:mov eax,33221100hmov ebx,eaxmov ecx,countmov ebx,offset countmov edx,[ebx]mov esi,[ebx+4]mov esi,4mov edi,count[esi]mov edi,[ebx+esi]mov ecx,[ebx+esi*4]mov edx,[ebx+esi*4-4]mov ebp,espcall disprdexit 0end start 4. 验证教材例题3-3，实现习题3.14程序。 eg0303123456789101112131415161718;eg0303.asm\tinclude io32.inc\t.dataminint\t= 10wvar1\tword 0,32768,65535,-32768,0,+32767wvar2\tword 1,-1,38,-38,38h,-38hwvar3\tword ?wvar4\tword 2010h,1020h\tword 5 dup(minint,?)wvar6\tword 3139h,3832hbvar6\tbyte 39h,31h,32h,38h\tbyte 0\t.codestart:\tmov eax,offset wvar6\tcall dispmsg\texit 0\tend start ex03141234567891011121314151617181920212223 include io32.inc .data;代码段table\tbyte &#x27; | 0 1 2 3 4 5 6 7 8 9 A B C D E F&#x27;,13,10 byte &#x27;---+-------------------------------&#x27;,13,10 byte &#x27;20 |&#x27;,20h,20h,21h,20h,22h,20h,23h,20h,24h,20h,25h,20h,26h,20h,27h,20h,28h,20h,29h,20h byte 2ah,20h,2bh,20h,2ch,20h,2dh,20h,2eh,20h,2fh,20h,13,10 byte &#x27;30 |&#x27;,30h,20h,31h,20h,32h,20h,33h,20h,34h,20h,35h,20h,36h,20h,37h,20h,38h,20h,39h,20h byte 3ah,20h,3bh,20h,3ch,20h,3dh,20h,3eh,20h,3fh,20h,13,10 byte &#x27;40 |&#x27;,40h,20h,41h,20h,42h,20h,43h,20h,44h,20h,45h,20h,46h,20h,47h,20h,48h,20h,49h,20h byte 4ah,20h,4bh,20h,4ch,20h,4dh,20h,4eh,20h,4fh,20h,13,10 byte &#x27;50 |&#x27;,50h,20h,51h,20h,52h,20h,53h,20h,54h,20h,55h,20h,56h,20h,57h,20h,58h,20h,59h,20h byte 5ah,20h,5bh,20h,5ch,20h,5dh,20h,5eh,20h,5fh,20h,13,10 byte &#x27;60 |&#x27;,60h,20h,61h,20h,62h,20h,63h,20h,64h,20h,65h,20h,66h,20h,67h,20h,68h,20h,69h,20h byte 6ah,20h,6bh,20h,6ch,20h,6dh,20h,6eh,20h,6fh,20h,13,10 byte &#x27;70 |&#x27;,70h,20h,71h,20h,72h,20h,73h,20h,74h,20h,75h,20h,76h,20h,77h,20h,78h,20h,79h,20h byte 7ah,20h,7bh,20h,7ch,20h,7dh,20h,7eh,20h,7fh,20h,13,10 byte 0 .codestart: mov eax,offset table call dispmsg exit 0 end start eg0423.asm123456789101112131415161718192021222324.686\t.model flat,stdcall\toption casemap:none\tincludelib bin\\kernel32.lib\tincludelib bin\\user32.libExitProcess proto,:DWORDMessageBoxA PROTO :DWORD,:DWORD,:DWORD,:DWORDMessageBox equ &lt;MessageBoxA&gt;NULL\tequ 0MB_OK equ 0\t.dataszCaption byte &#x27;消息窗口&#x27;,0outbuffer byte &#x27;本机的处理器是&#x27;, 12 dup(0),0outbufsize = sizeof outbuffer-1\t.codestart: mov eax,0\tcpuid ; 获得显示器信息\tmov dword ptr outbuffer+outbufsize-12,ebx\tmov dword ptr outbuffer+outbufsize-8,edx\tmov dword ptr outbuffer+outbufsize-4,ecx\tinvoke MessageBox,\\ NULL,addr outbuffer,addr szCaption,MB_OK\tinvoke ExitProcess,NULL\tend start 实验任务2：熟悉汇编语言中的常用传送和运算指令的应用 ex0320.asm123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960\tinclude io32.inc .codestart:\tmov eax,80h\tcall disprf\tcall disphd\tcall dispcrlf\tadd eax,3\tcall disprf\tcall disphd\tcall dispcrlf\tadd eax,80h\tcall disprf\tcall disphd\tcall dispcrlf\tadd eax,3\tcall disprf\tcall disphd\tcall dispcrlf\tcall dispcrlf\tmov eax,100\tcall disprf\tcall disphd\tcall dispcrlf\tadd ax,200\tcall disprf\tcall disphd\tcall dispcrlf\tcall dispcrlf\tmov eax,100\tcall disprf\tcall disphd\tcall dispcrlf\tadd al,200\tcall disprf\tcall disphd\tcall dispcrlf\tcall dispcrlf\tmov al,7fh\tcall disprf\tcall disphd\tcall dispcrlf\tsub al,8\tcall disprf\tcall disphd\tcall dispcrlf\tsub al,80h\tcall disprf\tcall disphd\tcall dispcrlf\tsbb al,3\tcall disprf\tcall disphd\tcall dispcrlf exit 0\tend start 实验任务3：掌握、理解位操作、串操作类指令 ex0328.asm12345678910111213141516\tinclude io32.inc\t.databcd\tbyte 92h\t.codestart:\tmov al,bcd\tshr al,4\tadd al,30h\tcall dispc\tmov al,bcd\tand al,0fh\tadd al,30h\tcall dispcexit 0end start 实验任务4：掌握转移指令和分支程序结构ex0405.asm1234567891011121314151617181920;ex0405.asm\tinclude io32.inc\t.datano_msg\tbyte &#x27;Not Ready!&#x27;,0yes_msg\tbyte &#x27;Ready to Go!&#x27;,0\t.codestart:\t;mov eax,58h\t; 假设一个数据\tmov eax,56h\t;test eax,02h\t; 测试D1位（使用D1＝1，其他位为0的数据）\tshr eax,2\t;jnz yesm\t; D1＝1条件成立，转移\tjnc yesm\tmov eax,offset no_msg\t; D1＝0，显示没有准备好\tjmp done\t; 跳转过另一个分支体！yesm:\tmov eax,offset yes_msg\t; 显示准备好done:\tcall dispmsg\texit 0\tend start ex0411.asm12345678910111213141516171819202122 include io32.inc .datainmsg\tbyte &#x27;Input number(0~9):&#x27;,0ermsg\tbyte 0dh,0ah,&#x27;ERROR! Input again:&#x27;,0 .codestart: mov eax,offset inmsg call dispmsgagain:\tcall readc cmp al,&#x27;0&#x27; jb erdisp cmp al,&#x27;9&#x27; ja erdisp call dispcrlf call dispc jmp doneerdisp:\tmov eax,offset ermsg call dispmsg jmp againdone: exit 0 end start 实验任务5：掌握循环指令和循环程序结构① 掌握循环指令和循环程序结构。验证例题4-12程序，实现习题4.13程序。 eg0412 12345678910111213141516171819;eg0412.asm\tinclude io32.inc\t.datastring\tbyte &#x27;Do you have fun with Assembly?&#x27;,0\t; 以0结尾的字符串\t.codestart:\txor ebx,ebx ;EBX用于记录字符个数，同时也用于指向字符的指针again: mov al,string[ebx]\tcmp al,0\tjz done\tinc ebx ;个数加1\tjmp again\t;继续循环done: mov eax,ebx ;显示个数\tcall dispuid exit 0\tend start ex04131234567891011121314151617181920212223\tinclude io32.inc\t.data\tstring byte &#x27;Do you have fun with Assembly ?&#x27;,0 ;以О结尾的字符串\tspace dword ?\t.codestart:\tmov esi,offset string\txor ebx, ebx; EBX用于记录空格数again:\tmov al,[esi]\tcmp al,0\tjz donecmp al, 20h ;空格的ASCII 码是20H\tjne next ;不相等、不是空格，转移\tinc bx ;相等、是空格，空格个数加1next:\tinc esi\tjmp again ;继续循环done:\tmov space, ebx ;保存结果\tmov eax,space\tcall dispuid\texit 0\tend start ② 验证例题4-10程序。实现如下程序：进行自然数相加（1＋2＋3＋……＋N）；如果（无符号整数的）累加和用一个32位寄存器存储，求出有效累加和的最大值及N的界限。eg0410.asm1234567891011121314151617181920212223242526272829303132333435include io32.inc.data.codestart: mov edx, 1 mov esi, 2done1: add edx, esi ; 自然数相加，求和 jc done ; 最高位进位，跳转 inc esi ; 加数加一 jmp done1 ; 重复进行自然数相加done: sub esi, 1 ; 加数减一，使累加和不进位而有效 mov ebx, 1 mov ecx, 2nom: add ebx, ecx ; 求得有效累加和 cmp ecx, esi ; 使加数到N的界限停止 jz again inc ecx ; 加数加一 jmp nom ; 重复进行自然数相加again: mov eax, ebx ; 显示有效累加和的最大值 call dispuid call dispcrlf ; 换行 mov eax, ecx ; 显示N的界限 call dispuidexit 0end start 来源：Q:现在你的环境为64位windows11系统，但是可以使用32位cmd运行make32指令。请基于使用io32.inc的32位汇编语言写一段代码，实现如下程序：进行自然数相加（1＋2＋3＋……＋N）；如果（无符号整数的）累加和用一个32位寄存器存储，求出有效累加和的最大值及N的界限，并且输出这两个变量。特别注意，请将可以输出结果的完整程序代码写出。A:当然，我可以帮你写一段32位汇编语言的代码来实现这个功能。首先，让我们来分析一下问题。 你需要计算自然数相加的累加和（1 + 2 + 3 + … + N），并且将结果存储在一个32位寄存器中。然后，你要找到有效累加和的最大值以及N的界限。 以下是一个满足你需求的汇编代码示例，使用了 io32.inc 文件：1234567891011121314151617181920212223242526272829303132333435include io32.inc.data.codestart: mov edx, 1 mov esi, 2done1: add edx, esi ; 自然数相加，求和 jc done ; 最高位进位，跳转 inc esi ; 加数加一 jmp done1 ; 重复进行自然数相加done: sub esi, 1 ; 加数减一，使累加和不进位而有效 mov ebx, 1 mov ecx, 2nom: add ebx, ecx ; 求得有效累加和 cmp ecx, esi ; 使加数到N的界限停止 jz again inc ecx ; 加数加一 jmp nom ; 重复进行自然数相加again: mov eax, ebx ; 显示有效累加和的最大值 call dispuid call dispcrlf ; 换行 mov eax, ecx ; 显示N的界限 call dispuidexit 0end start这段代码首先使用 edx 和 esi 寄存器进行自然数相加，直到累加和不再进位。然后，它计算有效累加和的最大值并找到N的界限。 请注意，这只是一个示例代码，你可以根据你的需求进行修改。如果你有其他问题或需要进一步的解释，请随时告知！[1][2][3] 希望这对你有所帮助！"},{"path":"/2024/05/23/平方数列求和的一种非正常求法/","content":"在高中数学的学习过程中，我们应该会知道这样一个公式： \\sum^n_{k=1}\\left(2k-1\\right)=n^2那么我们就会想到 \\sum^n_{k=1}k^2=\\sum^n_{k=1}\\left(\\sum^n_{k=1}\\left(2k-1\\right)\\right)展开来写，便是： \\begin{split} \\sum_{k=1}^n k^2 &= 1+(1+3)+(1+3+5)+\\dots+[1+3+5+\\dots+(2n-1)]\\\\ &= 1\\cdot n+3\\cdot (n-1)+5\\cdot (n-2)+\\dots +(2n-1)\\cdot [n-(n-1)]\\\\ &= n+(3n-3)+(5n-10)+\\dots +[(2n-1)n-(2n-1)(n-1)]\\\\ &= (\\textstyle\\sum_{k=1}^n(2k-1))\\cdot n-\\textstyle\\sum_{k=1}^n[(2k-1)(k-1)]\\\\ &= n^2\\cdot n-\\textstyle\\sum_{k=1}^n(2k^2-3k+1)\\\\ &= n^3-2\\textstyle\\sum_{k=1}^nk^2+3\\textstyle\\sum_{k=1}^nk-\\textstyle\\sum_{k=1}^n\\\\ &=n^3-2\\textstyle\\sum_{k=1}^nk^2+3\\cdot\\frac{n(1+n)}{2}-n \\end{split}那么，我们就可以把 $\\sum^n_{k=1}k^2$ 放在等号的一侧，即 3\\sum\\limits_{k=1}^{n}{k^2}=n^3+\\frac{3n(1+n)}{2}-n于是， \\sum\\limits_{k=1}^{n}{k^2}=\\frac{n^3+\\frac{3n(1+n)}{2}-n}{3}=\\frac{2n^3+3n^2+n}{6}=\\frac{n(n+1)(2n+1)}{6}"},{"path":"/2024/05/23/电子设计自动化实验相关/","content":"本文内容基于电子设计自动化老师发的 实验报告模板 实验基于FPGA黑金开发平台AX301，此款开发板使用的是 ALTERA 公司的 Cyclone IV 系列 FPGA，型号为 EP4CE6F17C8 实验一：LED流水灯设计codes led_test.v 12345678910111213141516171819202122232425262728293031323334353637`timescale 1ns / 1psmodule led_test(\tinput clk, // system clock 50Mhz on board\tinput rst_n, // reset ,low active\toutput reg[3:0] led // LED,use for control the LED signal on board);//define the time counterreg [31:0] timer;// cycle counter:from 0 to 4 secalways@(posedge clk or negedge rst_n)begin\tif (rst_n == 1&#x27;b0) timer &lt;= 32&#x27;d0; //when the reset signal valid,time counter clearing\telse if (timer == 32&#x27;d199_999_999) //4 seconds count(50M*4-1=199999999) timer &lt;= 32&#x27;d0; //count done,clearing the time counter\telse timer &lt;= timer + 32&#x27;d1; //timer counter = timer counter + 1end// LED controlalways@(posedge clk or negedge rst_n)begin\tif (rst_n == 1&#x27;b0) led &lt;= 4&#x27;b0000; //when the reset signal active\telse if (timer == 32&#x27;d49_999_999) //time counter count to 1st sec,LED1 lighten led &lt;= 4&#x27;b0001;\telse if (timer == 32&#x27;d99_999_999) //time counter count to 2nd sec,LED2 lighten led &lt;= 4&#x27;b0010;\telse if (timer == 32&#x27;d149_999_999) //time counter count to 3rd sec,LED3 lighten led &lt;= 4&#x27;b0100;\telse if (timer == 32&#x27;d199_999_999) //time counter count to 4th sec,LED4 lighten led &lt;= 4&#x27;b1000;endendmodule 实验二：数码管动态显示codes seg_test.v 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137module seg_test( input clk, input rst_n, output[5:0]seg_sel, output[7:0]seg_data ); reg[31:0] timer_cnt;reg en_1hz; //1 second , 1 counter enablealways@(posedge clk or negedge rst_n)begin if(rst_n == 1&#x27;b0) begin en_1hz &lt;= 1&#x27;b0; timer_cnt &lt;= 32&#x27;d0; end else if(timer_cnt &gt;= 32&#x27;d49_999_999) begin en_1hz &lt;= 1&#x27;b1; timer_cnt &lt;= 32&#x27;d0; end else begin en_1hz &lt;= 1&#x27;b0; timer_cnt &lt;= timer_cnt + 32&#x27;d1; endendwire[3:0] count0;wire t0;count_m10 count10_m0( .clk (clk), .rst_n (rst_n), .en (en_1hz), .clr (1&#x27;b0), .data (count0), .t (t0) );wire[3:0] count1;wire t1;count_m6 count6_m1(\t//oringin: count_m10 count10_m1 .clk (clk), .rst_n (rst_n), .en (t0), .clr (1&#x27;b0), .data (count1), .t (t1) );wire[3:0] count2;wire t2;count_m10 count10_m2( .clk (clk), .rst_n (rst_n), .en (t1), .clr (1&#x27;b0), .data (count2), .t (t2));wire[3:0] count3;wire t3;count_m10 count10_m3( .clk (clk), .rst_n (rst_n), .en (t2), .clr (1&#x27;b0), .data (count3), .t (t3));wire[3:0] count4;wire t4;count_m10 count10_m4( .clk (clk), .rst_n (rst_n), .en (t3), .clr (1&#x27;b0), .data (count4), .t (t4));wire[3:0] count5;wire t5;count_m10 count10_m5( .clk (clk), .rst_n (rst_n), .en (t4), .clr (1&#x27;b0), .data (count5), .t (t5));wire[6:0] seg_data_0;seg_decoder seg_decoder_m0( .bin_data (count5), .seg_data (seg_data_0));wire[6:0] seg_data_1;seg_decoder seg_decoder_m1( .bin_data (count4), .seg_data (seg_data_1));wire[6:0] seg_data_2;seg_decoder seg_decoder_m2( .bin_data (count3), .seg_data (seg_data_2));wire[6:0] seg_data_3;seg_decoder seg_decoder_m3( .bin_data (count2), .seg_data (seg_data_3));wire[6:0] seg_data_4;seg_decoder seg_decoder_m4( .bin_data (count1),\t//attention, this is COUNT1 .seg_data (seg_data_4));wire[6:0] seg_data_5;seg_decoder seg_decoder_m5( .bin_data (count0), .seg_data (seg_data_5));seg_scan seg_scan_m0( .clk (clk), .rst_n (rst_n), .seg_sel (seg_sel), .seg_data (seg_data),// .seg_data_0 (&#123;1&#x27;b1,seg_data_0&#125;), //The decimal point at the highest bit,and low level effecitve// .seg_data_1 (&#123;1&#x27;b1,seg_data_1&#125;), // .seg_data_2 (&#123;1&#x27;b1,seg_data_2&#125;),// .seg_data_3 (&#123;1&#x27;b1,seg_data_3&#125;), .seg_data_4 (&#123;1&#x27;b1,seg_data_4&#125;), .seg_data_5 (&#123;1&#x27;b1,seg_data_5&#125;));endmodule seg_scan.v 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192module seg_scan(\tinput clk,\tinput rst_n,\toutput reg[5:0] seg_sel, //digital led chip select\toutput reg[7:0] seg_data, //eight segment digital tube output,MSB is the decimal point//\tinput[7:0] seg_data_0,//\tinput[7:0] seg_data_1,//\tinput[7:0] seg_data_2,//\tinput[7:0] seg_data_3,\tinput[7:0] seg_data_4,\tinput[7:0] seg_data_5);parameter SCAN_FREQ = 200; //scan frequencyparameter CLK_FREQ = 50000000; //clock frequencyparameter SCAN_COUNT = CLK_FREQ /(SCAN_FREQ * 6) - 1;reg[31:0] scan_timer; //scan time counterreg[3:0] scan_sel; //Scan select counteralways@(posedge clk or negedge rst_n)begin\tif(rst_n == 1&#x27;b0)\tbegin scan_timer &lt;= 32&#x27;d0; scan_sel &lt;= 4&#x27;d0;\tend\telse if(scan_timer &gt;= SCAN_COUNT)\tbegin scan_timer &lt;= 32&#x27;d0; if(scan_sel == 4&#x27;d5) scan_sel &lt;= 4&#x27;d0; else scan_sel &lt;= scan_sel + 4&#x27;d1;\tend\telse begin scan_timer &lt;= scan_timer + 32&#x27;d1; endendalways@(posedge clk or negedge rst_n)begin\tif(rst_n == 1&#x27;b0)\tbegin seg_sel &lt;= 6&#x27;b111111; seg_data &lt;= 8&#x27;hff;\tend\telse\tbegin case(scan_sel)// //first digital led// 4&#x27;d0:// begin// seg_sel &lt;= 6&#x27;b11_1110;// seg_data &lt;= seg_data_0;// end// //second digital led// 4&#x27;d1:// begin// seg_sel &lt;= 6&#x27;b11_1101;// seg_data &lt;= seg_data_1;// end// //...// 4&#x27;d2:// begin// seg_sel &lt;= 6&#x27;b11_1011;// seg_data &lt;= seg_data_2;// end// 4&#x27;d3:// begin// seg_sel &lt;= 6&#x27;b11_0111;// seg_data &lt;= seg_data_3;// end 4&#x27;d4: begin seg_sel &lt;= 6&#x27;b10_1111; seg_data &lt;= seg_data_4; end 4&#x27;d5: begin seg_sel &lt;= 6&#x27;b01_1111; seg_data &lt;= seg_data_5; end default: begin seg_sel &lt;= 6&#x27;b11_1111; seg_data &lt;= 8&#x27;hff; end endcase\tendendendmodule count_m10.v 1234567891011121314151617181920212223242526272829303132333435363738module count_m10( input clk, input rst_n, input en, //Counter enable input clr, //Counter synchronous reset output reg[3:0]data, //counter value output reg t // carry enable signal );always@(posedge clk or negedge rst_n) begin if(rst_n==0) begin data &lt;= 4&#x27;d0; t &lt;= 1&#x27;d0; end else if(clr) begin data &lt;= 4&#x27;d0; t &lt;= 1&#x27;d0; end else if(en) begin if(data==4&#x27;d9) begin t&lt;= 1&#x27;b1; //Counter to 9 to generate carry data &lt;= 4&#x27;d0;//Counter to 9 reset end else begin t &lt;= 1&#x27;b0; data &lt;= data + 4&#x27;d1; end end else t &lt;= 1&#x27;b0;endendmodule count_m6.v 1234567891011121314151617181920212223242526272829303132333435363738module count_m6( input clk, input rst_n, input en, //Counter enable input clr, //Counter synchronous reset output reg[3:0]data, //counter value output reg t // carry enable signal );always@(posedge clk or negedge rst_n) begin if(rst_n==0) begin data &lt;= 4&#x27;d0; t &lt;= 1&#x27;d0; end else if(clr) begin data &lt;= 4&#x27;d0; t &lt;= 1&#x27;d0; end else if(en) begin if(data==4&#x27;d5) begin t&lt;= 1&#x27;b1; //Counter to 5 to generate carry data &lt;= 4&#x27;d0;//Counter to 5 reset end else begin t &lt;= 1&#x27;b0; data &lt;= data + 4&#x27;d1; end end else t &lt;= 1&#x27;b0;endendmodule seg_decoder.v 1234567891011121314151617181920212223242526272829module seg_decoder(\tinput[3:0] bin_data, // bin data input\toutput reg[6:0] seg_data // seven segments LED output //origin: [6:0]);always@(*)begin\tcase(bin_data) 4&#x27;d0:seg_data &lt;= 7&#x27;b100_0000; 4&#x27;d1:seg_data &lt;= 7&#x27;b111_1001; 4&#x27;d2:seg_data &lt;= 7&#x27;b010_0100; 4&#x27;d3:seg_data &lt;= 7&#x27;b011_0000; 4&#x27;d4:seg_data &lt;= 7&#x27;b001_1001; 4&#x27;d5:seg_data &lt;= 7&#x27;b001_0010; 4&#x27;d6:seg_data &lt;= 7&#x27;b000_0010; 4&#x27;d7:seg_data &lt;= 7&#x27;b111_1000; 4&#x27;d8:seg_data &lt;= 7&#x27;b000_0000; 4&#x27;d9:seg_data &lt;= 7&#x27;b001_0000; 4&#x27;ha:seg_data &lt;= 7&#x27;b000_1000; 4&#x27;hb:seg_data &lt;= 7&#x27;b000_0011; 4&#x27;hc:seg_data &lt;= 7&#x27;b100_0110; 4&#x27;hd:seg_data &lt;= 7&#x27;b010_0001; 4&#x27;he:seg_data &lt;= 7&#x27;b000_0110; 4&#x27;hf:seg_data &lt;= 7&#x27;b000_1110; default:seg_data &lt;= 7&#x27;b111_1111;\tendcaseendendmodule 实验三 数字时钟（计数器）codes在实验二代码的基础上，把前边代码中注释掉的部分取消注释，然后添加下边两个： count_m24_x.v 1234567891011121314151617181920212223242526272829303132333435363738module count_m24_x( input clk, input rst_n, input en, //Counter enable input clr, //Counter synchronous reset output reg[3:0]data, //counter value output reg t // carry enable signal );always@(posedge clk or negedge rst_n) begin if(rst_n==0) begin data &lt;= 4&#x27;d0; t &lt;= 1&#x27;d0; end else if(clr) begin data &lt;= 4&#x27;d0; t &lt;= 1&#x27;d0; end else if(en) begin if(data==4&#x27;d2) begin t&lt;= 1&#x27;b1; //Counter to 2 to generate carry data &lt;= 4&#x27;d0;//Counter to 2 reset end else begin t &lt;= 1&#x27;b0; data &lt;= data + 4&#x27;d1; end end else t &lt;= 1&#x27;b0;endendmodule count_m24_y.v 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950module count_m24_y( input clk, input rst_n, input en, //Counter enable input clr, //Counter synchronous reset output reg[3:0]data, //counter value output reg t // carry enable signal ); reg[3:0] y_timer;\t// 24_y timeralways@(posedge clk or negedge rst_n)begin if(rst_n==0) begin data &lt;= 4&#x27;d0; t &lt;= 1&#x27;d0; y_timer &lt;= 4&#x27;d0; end else if(clr) begin data &lt;= 4&#x27;d0; t &lt;= 1&#x27;d0; y_timer &lt;= 4&#x27;d0; end else if(en) begin if(data==4&#x27;d9) begin t&lt;= 1&#x27;b1; //Counter to 9 to generate carry data &lt;= 4&#x27;d0;//Counter to 9 reset y_timer &lt;= y_timer + 4&#x27;d1; end else if(data==4&#x27;d3 &amp;&amp; y_timer==4&#x27;d2) begin t &lt;= 1&#x27;b1; data &lt;= 4&#x27;d0; y_timer &lt;= 4&#x27;d0; end else begin t &lt;= 1&#x27;b0; data &lt;= data + 4&#x27;d1; end end else t &lt;= 1&#x27;b0;endendmodule 然后，在seg_test.v里边，第89行的wire t3的count_m10改成count_m6，然后把第100行和111行的wire t4和wire t5的count_m10分别改为count_m24_y和count_m24_x即可实现。 另外，如果需要加快时钟的速度，可以修改seg_test.v第45行的32&#39;d49_999_999为32&#39;d49_999，这样分钟的十位会按比秒稍微快一点的速度计数。 实验四：正弦信号发生器设计codes sinwave1.v 123456789101112131415161718192021module sinwave1(clk,rst_n,dout);input clk,rst_n;output [7:0] dout;reg[7:0] address;reg rden;always@(posedge clk or negedge rst_n)begin\tif (!rst_n) rden&lt;=0;\telse rden&lt;=1;endalways@(posedge clk or negedge rst_n)begin\tif (!rst_n) address&lt;=0;\telse address&lt;=address+1;endmyrom1 u1(.address(address),.clock(clk),.rden(rden),.q(dout));endmodule 实验五：任意波形发生器设计codes hechengbo.v 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566module hechengbo(\tinput clk,\tinput rst,\toutput [7:0] q1,\toutput [7:0] q2, output [7:0] q3, output [7:0] q4, output [8:0] q5, output [8:0] q6, output [8:0] q7, output [8:0] q8, output [8:0] q9, output [8:0] q10,\toutput [9:0] q11,\toutput [9:0] q12, output [9:0] q13, output [9:0] q14, output [10:0] q15 );reg [8:0] address;\talways @ (negedge clk or negedge rst)begin\tif(!rst) address &lt;= 1&#x27;b0;\telse address &lt;= address+1&#x27;b1;endsinewave ROM_1( .address(address), .clock (clk), .q (q1));fangbo ROM_2( .address(address), .clock (clk), .q (q2));jvchibo ROM_3( .address(address), .clock (clk), .q (q3));sanjiaobo\tROM_4( .address(address), .clock (clk), .q (q4));assign q5=q1+q2;assign q6=q1+q3;assign q7=q1+q4;assign q8=q3+q2;assign q9=q4+q2;assign q10=q1+q3+q4;assign q11=q1+q2+q3;assign q12=q1+q2+q4;assign q13=q2+q3+q4;assign q14=q3+q4;assign q15=q1+q2+q3+q4;endmodule 实验六：硬件消抖电路设计codes seg_scan.v 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192module seg_scan(\tinput clk,\tinput rst_n,\toutput reg[5:0] seg_sel, //digital led chip select\toutput reg[7:0] seg_data, //eight segment digital tube output,MSB is the decimal point\tinput[7:0] seg_data_0,\tinput[7:0] seg_data_1,\tinput[7:0] seg_data_2,\tinput[7:0] seg_data_3,\tinput[7:0] seg_data_4,\tinput[7:0] seg_data_5);parameter SCAN_FREQ = 200; //scan frequencyparameter CLK_FREQ = 50000000; //clock frequencyparameter SCAN_COUNT = CLK_FREQ /(SCAN_FREQ * 6) - 1;reg[31:0] scan_timer; //scan time counterreg[3:0] scan_sel; //Scan select counteralways@(posedge clk or negedge rst_n)begin\tif(rst_n == 1&#x27;b0)\tbegin scan_timer &lt;= 32&#x27;d0; scan_sel &lt;= 4&#x27;d0;\tend\telse if(scan_timer &gt;= SCAN_COUNT)\tbegin scan_timer &lt;= 32&#x27;d0; if(scan_sel == 4&#x27;d5) scan_sel &lt;= 4&#x27;d0; else scan_sel &lt;= scan_sel + 4&#x27;d1;\tend\telse begin scan_timer &lt;= scan_timer + 32&#x27;d1; endendalways@(posedge clk or negedge rst_n)begin\tif(rst_n == 1&#x27;b0)\tbegin seg_sel &lt;= 6&#x27;b111111; seg_data &lt;= 8&#x27;hff;\tend\telse\tbegin case(scan_sel) //first digital led 4&#x27;d0: begin seg_sel &lt;= 6&#x27;b11_1110; seg_data &lt;= seg_data_0; end //second digital led 4&#x27;d1: begin seg_sel &lt;= 6&#x27;b11_1101; seg_data &lt;= seg_data_1; end //... 4&#x27;d2: begin seg_sel &lt;= 6&#x27;b11_1011; seg_data &lt;= seg_data_2; end 4&#x27;d3: begin seg_sel &lt;= 6&#x27;b11_0111; seg_data &lt;= seg_data_3; end 4&#x27;d4: begin seg_sel &lt;= 6&#x27;b10_1111; seg_data &lt;= seg_data_4; end 4&#x27;d5: begin seg_sel &lt;= 6&#x27;b01_1111; seg_data &lt;= seg_data_5; end default: begin seg_sel &lt;= 6&#x27;b11_1111; seg_data &lt;= 8&#x27;hff; end endcase\tendendendmodule seg_decoder.v 1234567891011121314151617181920212223242526272829module seg_decoder(\tinput[3:0] bin_data, // bin data input\toutput reg[6:0] seg_data // seven segments LED output);always@(*)begin\tcase(bin_data) 4&#x27;d0:seg_data &lt;= 7&#x27;b100_0000; 4&#x27;d1:seg_data &lt;= 7&#x27;b111_1001; 4&#x27;d2:seg_data &lt;= 7&#x27;b010_0100; 4&#x27;d3:seg_data &lt;= 7&#x27;b011_0000; 4&#x27;d4:seg_data &lt;= 7&#x27;b001_1001; 4&#x27;d5:seg_data &lt;= 7&#x27;b001_0010; 4&#x27;d6:seg_data &lt;= 7&#x27;b000_0010; 4&#x27;d7:seg_data &lt;= 7&#x27;b111_1000; 4&#x27;d8:seg_data &lt;= 7&#x27;b000_0000; 4&#x27;d9:seg_data &lt;= 7&#x27;b001_0000; 4&#x27;ha:seg_data &lt;= 7&#x27;b000_1000; 4&#x27;hb:seg_data &lt;= 7&#x27;b000_0011; 4&#x27;hc:seg_data &lt;= 7&#x27;b100_0110; 4&#x27;hd:seg_data &lt;= 7&#x27;b010_0001; 4&#x27;he:seg_data &lt;= 7&#x27;b000_0110; 4&#x27;hf:seg_data &lt;= 7&#x27;b000_1110; default:seg_data &lt;= 7&#x27;b111_1111;\tendcaseendendmodule key_debounce.v 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263module key_debounce( input clk, input rst_n,\tinput key1, output [5:0] seg_sel, output [7:0] seg_data);wire button_negedge; //Key falling edgeax_debounce ax_debounce_m0( .clk (clk), .rst (~rst_n), .button_in (key1), .button_posedge (), .button_negedge (button_negedge), .button_out ());wire[3:0] count;wire t0;count_m10 count10_m0( .clk (clk), .rst_n (rst_n), .en (button_negedge), .clr (1&#x27;b0), .data (count), .t (t0));wire[3:0] count1;wire t1;count_m6 count10_m1( .clk (clk), .rst_n (rst_n), .en (t0), .clr (1&#x27;b0), .data (count1), .t (t1));//Count decodingwire[6:0] seg_data_0;seg_decoder seg_decoder_m0( .bin_data (count), .seg_data (seg_data_0));wire[6:0] seg_data_1;seg_decoder seg_decoder_m1( .bin_data (count1), .seg_data (seg_data_1));seg_scan seg_scan_m0( .clk (clk), .rst_n (rst_n), .seg_sel (seg_sel), .seg_data (seg_data), .seg_data_0 (&#123;1&#x27;b1,7&#x27;b1111_111&#125;), .seg_data_1 (&#123;1&#x27;b1,7&#x27;b1111_111&#125;), .seg_data_2 (&#123;1&#x27;b1,7&#x27;b1111_111&#125;), .seg_data_3 (&#123;1&#x27;b1,7&#x27;b1111_111&#125;), .seg_data_4 (&#123;1&#x27;b1,seg_data_1&#125;), .seg_data_5 (&#123;1&#x27;b1,seg_data_0&#125;));endmodule count_m10.v 1234567891011121314151617181920212223242526272829303132333435363738module count_m10( input clk, input rst_n, input en, //Counter enable input clr, //Counter synchronous reset output reg[3:0]data, //counter value output reg t // carry enable signal );always@(posedge clk or negedge rst_n) begin if(rst_n==0) begin data &lt;= 4&#x27;d0; t &lt;= 1&#x27;d0; end else if(clr) begin data &lt;= 4&#x27;d0; t &lt;= 1&#x27;d0; end else if(en) begin if(data==4&#x27;d9) begin t&lt;= 1&#x27;b1; //Counter to 9 to generate carry data &lt;= 4&#x27;d0;//Counter to 9 reset end else begin t &lt;= 1&#x27;b0; data &lt;= data + 4&#x27;d1; end end else t &lt;= 1&#x27;b0;endendmodule ax_debounce.v 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485`timescale 1 ns / 100 psmodule ax_debounce ( input clk, input rst, input button_in, output reg button_posedge, output reg button_negedge, output reg button_out);//// ---------------- internal constants --------------parameter N = 32 ; // debounce timer bitwidthparameter FREQ = 50; //model clock :Mhzparameter MAX_TIME = 20; //mslocalparam TIMER_MAX_VAL = MAX_TIME * 1000 * FREQ;////---------------- internal variables ---------------reg [N-1 : 0] q_reg; // timing regsreg [N-1 : 0] q_next;reg DFF1, DFF2; // input flip-flopswire q_add; // control flagswire q_reset;reg button_out_d0;//// ------------------------------------------------------////contenious assignment for counter controlassign q_reset = (DFF1 ^ DFF2); // xor input flip flops to look for level chage to reset counterassign q_add = ~(q_reg == TIMER_MAX_VAL); // add to counter when q_reg msb is equal to 0 //// combo counter to manage q_next always @ ( q_reset, q_add, q_reg)begin case( &#123;q_reset , q_add&#125;) 2&#x27;b00 : q_next &lt;= q_reg; 2&#x27;b01 : q_next &lt;= q_reg + 1; default : q_next &lt;= &#123; N &#123;1&#x27;b0&#125; &#125;; endcase end//// Flip flop inputs and q_reg updatealways @ ( posedge clk or posedge rst)begin if(rst == 1&#x27;b1) begin DFF1 &lt;= 1&#x27;b0; DFF2 &lt;= 1&#x27;b0; q_reg &lt;= &#123; N &#123;1&#x27;b0&#125; &#125;; end else begin DFF1 &lt;= button_in; DFF2 &lt;= DFF1; q_reg &lt;= q_next; endend//// counter controlalways @ ( posedge clk or posedge rst)begin\tif(rst == 1&#x27;b1) button_out &lt;= 1&#x27;b1; else if(q_reg == TIMER_MAX_VAL) button_out &lt;= DFF2; else button_out &lt;= button_out;endalways @ ( posedge clk or posedge rst)begin\tif(rst == 1&#x27;b1)\tbegin button_out_d0 &lt;= 1&#x27;b1; button_posedge &lt;= 1&#x27;b0; button_negedge &lt;= 1&#x27;b0;\tend\telse\tbegin button_out_d0 &lt;= button_out; button_posedge &lt;= ~button_out_d0 &amp; button_out; button_negedge &lt;= button_out_d0 &amp; ~button_out;\tend\tendendmodule count_m6.v 1234567891011121314151617181920212223242526272829303132333435363738module count_m6( input clk, input rst_n, input en, //Counter enable input clr, //Counter synchronous reset output reg[3:0]data, //counter value output reg t // carry enable signal );always@(posedge clk or negedge rst_n) begin if(rst_n==0) begin data &lt;= 4&#x27;d0; t &lt;= 1&#x27;d0; end else if(clr) begin data &lt;= 4&#x27;d0; t &lt;= 1&#x27;d0; end else if(en) begin if(data==4&#x27;d5) begin t&lt;= 1&#x27;b1; //Counter to 5 to generate carry data &lt;= 4&#x27;d0;//Counter to 5 reset end else begin t &lt;= 1&#x27;b0; data &lt;= data + 4&#x27;d1; end end else t &lt;= 1&#x27;b0;endendmodule"},{"title":"电子设计自动化实验报告","path":"/2024/05/23/电子设计自动化实验报告/","content":"电子设计自动化-实验报告 实验一：LED流水灯设计 一、实验目的 熟悉QuartusII开发环境 掌握FPGA开发流程 二、实验内容及原理1. 实验内容通过设计计数器，实现LED流水灯的效果 2. 实验原理 LED硬件电路 从上面的 LED 部分原理图可以看出，LED 电路有两个方式，AX301 开发板将 IO 经过一个电阻和 LED 串联接地，IO 输出高电平点亮 LED。其中的串联电阻是为了限制电流。 程序设计 FPGA 的设计中通常使用计数器来计时，对于 50Mhz 的系统时钟，一个时钟周期是 20ns，那 么表示一秒需要 50000000 个时钟周期，如果一个时钟周期计数器累加一次，那么计数器从 0 到 49999999 正好是 50000000 个周期，就是 1 秒的时钟。 程序中定义了一个 32 位的计数器： 12//Define the time counter reg [31:0] timer; 最大可以表示 4294967295，十六进制就是 FFFFFFFF，如果计数器到最大值，可以表示 85.89934592 秒。程序设计中是每隔 1 秒 LED 变化一次，一共消耗 4 秒做一个循环。 123456789always@(posedge clk or negedge rst_n)beginif (rst_n == 1&#x27;b0) timer &lt;= 32&#x27;d0; else if (timer == 32&#x27;d199_999_999) timer &lt;= 32&#x27;d0; elsetimer &lt;= timer + 32&#x27;d1; end 在第一秒、第二秒、第三秒、第四秒到来的时候分别改变 LED 的状态，其他时候都保持原来 的值不变。 1234567891011121314// LED controlalways@(posedge clk or negedge rst_n)beginif (rst_n == 1&#x27;b0)led &lt;= 4&#x27;b0000; else if (timer == 32&#x27;d49_999_999) led &lt;= 4&#x27;b0001;else if (timer == 32&#x27;d99_999_999) led &lt;= 4&#x27;b0010;else if (timer == 32&#x27;d149_999_999) led &lt;= 4&#x27;b0100;else if (timer == 32&#x27;d199_999_999) led &lt;= 4&#x27;b1000;end 三、实验步骤及结果1. 建立工程（1） 启动 Quartus (Quartus Prime 17.1) Lite Edition 开发环境，选择菜单 File-&gt;New Project Wizerd （2） 选择“Next&gt;” （3） 添加工程路径，工程名称，顶层设计实体名称，顶层设计实体名称默认和工程名称一 致，可以修改为不一致。顶层设计实体名称在设计中必须存在而且和这里设置的一致， 本实验顶层设计指定为 led_test，设计中就要有 module led_test，大小写敏感。在 quartus 软件中也可以指定某一个模块为顶层模块。 （4） 工程类型选择空工程 （5） 添加文件，这个时候没有任何设计文件，直接 Next （6） 芯片选择，AX301 开发板 器件选择 Cyclone IV E（EP4CE6F17C8） （7） EDA 工具设置，这里默认即可 （8） 完成工程向导 （9） 返回 Quartus 工作界面 2. 编写代码（1） 新建 Verilog HDL 文件 （2） 编写 Verilog 代码 （3） 代码写入完成后点击保存。这里默认将这个文件添加到工程中。 （4） 查看工程里的文件，在工程导航的下拉菜单里选择 Files 即可。 （5）文件的操作。选择某个文件，右键，可以看到一些操作选项，“Remove File from Project”，将文件移除工程，“Set as Top-Level Entity”设置为顶层实体，如果建立工 程时指定的顶层实体名称不对，可以在这里修改。本实验这里无需做任何修改和操作。 3. 其他设置（1）设置未用管脚和默认电平标准，选择 Assignments -&gt; Device 即可打开器件配置，如果 前面选择选择不正确，这里可以重新选择器件。 （2）点击“Device and Pin Options”在“Unused Pins”选项中”Reserve unused pins”,设置为 “As input tri-stated”，这里是把没有使用的管脚做为三态输入。 （3）在“Voltage”选项，将“Default I/O standard:”设置为“3.3-V LVTTL”，这个设置是 和 FPGA 硬件设计的 bank 电压有关，黑金的大部分开发板的 IO BNAK 电压为 3.3V，所 以设置为“3.3-V LVTTL”。输出电压和设置没有关系，如果 BANK 电压是 3.3V，你这 里设置 2.5V，也不会改变 IO 输出的电压幅度。这里设置完成以后 IO 的默认电压为 “3.3-V LVTTL”，我们也可以根据需要为每个 IO 分配不一样的 IO 电平标准。 （4）多用途管脚设置。在选项“Dual-Purpose Pins”中设置多用途 IO，全部做为普通 IO。 这些多用途管脚，在 FPGA 配置阶段有特殊用途，配置完成后可以做为普通 IO。 （5）预编译。没有分配管脚，但是我们需要预编译一下（完成第一阶段综合过程），让 quartus 分析设计中的输入输出管脚。编译过程中信息显示窗口不断显示出各种信息， 如果出现红色，表示有错误，双击这条信息可以定位具体错误位置。 （6）IO 管脚分配。管脚分配的目的是为设计和实际的硬件电路关联起来，这里的连接关系 从硬件原理图得来。 （7） 在“Location”列填入 led、时钟、的管脚名称，需要注意是：一定要在“Location” 列填写。小技巧：这个表格可以像 EXCEL 表格一样复制粘贴，可以从其他工程的管脚 分配复制过来，然后粘贴，也可以在一个 EXCEL 表格里复制过来。管脚分配完成以后 关闭窗口就可以。需要注意的是：每个 IO 都必须分配管脚，如果有未分配的 IO，软 件可能会随机分配，造成不可预料的后果，严重时可烧坏 FPGA 芯片。 4. 编译下载（1）再次编译。上次编译时还没有分配管脚，分配管脚后我们在任务流程窗口可以看到只 有第一下流程“综合”是“√”状态，其他都是“？”状态，“？”状态表示需要重 新编译才行。为了方便，这里双击“Compile Design”，完成全部编译流程。 （2）编译完成以后可以看到一个编译报告，主要报告各种资源的使用情况。在 output_files 文件夹我们可以看到一个 test_led.sof 文件，这个文件可以通过 JTAG 方式下载到 FPGA 运行，但不能直接固化到 Flash。 （3）将下载器连接 PC 和开发板，接通电源（注意要先插下载器的 JTAG 排线，然后再 上电） （4）打开下载界面，这里通过工具栏快捷方式点击下载按钮。很多操作都可以在这里快速 点击进行。 （5）正常情况下弹出的窗口 Mode 已经选择 JTAG 模式，下载器已经识别到了，并且下载 文件都已经找好。需要注意的是：芯片型号跟开发板必须一致，否则会无法下载；下 载的 sof 文件一次只能添加一个。一切正常，点击“start”按钮，进度条开始滚动， 遇到错误时，Quartus 信息窗口会显示出具体的错误。 （6）如果没有识别到下载器，可以点击“Hardware Setup”，双击列表中的下载器即可。 如果列表中没有任何下载器，检查设备管理器里是不是有“Altera USB-Blaster”，如 果硬件设备管理器中有，Quartus 无法识别，通常是装了多个版本的 Quartus 造成的。 5. 固化程序到flash在黑金 FPGA 开发板中使用 SPI Flash 固化 FPGA 程序。 5.1. 转换jic文件（1） Quartus 里选择菜单“File -&gt; Convert Programming Files….” （2） 选择“Programming file type”为“JTAG Indirect Configuration File(.jic)”。 “Configuration device”根据开发板型号选择，AX301 开发板、AX4010 开发板选择 EPCS16（指 16M Flash），AX515 开发板、AX530 开发板选择 EPCS64（指 64M Flash）。 （3） “Flash Loader”选中，点击“Add Device” （4） 器件选择根据开发板型号选择，AX301 开发板选择“EP4CE6” （5） 选择“SOF Data”栏，点击“Add File…” （6） 选择要固化的 sof 文件, 这里我们选择前面生成的流水灯 led_test.sof 文件。 （7） 点击“Genrate”就可以生成 jic 文件 5.2. 固化到flash（1） 打开下载管理界面，删除其他已有的下载文件，添加上面生成的 jic 文件，注意，只保 留一个 jic 文件。在”Program/Configure”打钩“√”。点击“Start”按钮。 （2） 下载 Flash 后，断电重启开发板，程序就可以运行了 6. 擦除Flash中已有的程序（1） 如果要擦除 Flash 中的程序，先添加一个 jic 文件（只有一个 jic 文件），选择“Erase” 列，点击“Start”，完成擦写。 四、实验中遇到的问题及解决方法跟着实验步骤一次实现，所以暂无遇到问题。 五、源程序和testbench代码 led_test.v 12345678910111213141516171819202122232425262728293031323334`timescale 1ns / 1psmodule led_test(input clk, // system clock 50Mhz on boardinput rst_n, // reset ,low activeoutput reg[3:0] led // LED,use for control the LED signal on board);//define the time counterreg [31:0] timer;// cycle counter:from 0 to 4 secalways@(posedge clk or negedge rst_n)beginif (rst_n == 1&#x27;b0)timer &lt;= 32&#x27;d0; //when the reset signal valid,time counter clearingelse if (timer == 32&#x27;d199_999_999) //4 seconds count(50M*4-1=199999999)timer &lt;= 32&#x27;d0; //count done,clearing the time counterelsetimer &lt;= timer + 32&#x27;d1; //timer counter = timer counter + 1end// LED controlalways@(posedge clk or negedge rst_n)beginif (rst_n == 1&#x27;b0)led &lt;= 4&#x27;b0000; //when the reset signal activeelse if (timer == 32&#x27;d49_999_999) //time counter count to 1st sec,LED1 lightenled &lt;= 4&#x27;b0001;else if (timer == 32&#x27;d99_999_999) //time counter count to 2nd sec,LED2 lightenled &lt;= 4&#x27;b0010;else if (timer == 32&#x27;d149_999_999) //time counter count to 3rd sec,LED3 lightenled &lt;= 4&#x27;b0100;else if (timer == 32&#x27;d199_999_999) //time counter count to 4th sec,LED4 lightenled &lt;= 4&#x27;b1000;endendmodule 六、心得体会在学习FPGA开发过程中，我尝试了基于AX301开发板的LED流水灯设计实验。以下是我的心得体会： AX301开发板概述： AX301是一款基础的学生实验板，用于学习FPGA开发。它采用ALTERA公司的CYCLONE IV系列FPGA，型号为EP4CE6F17C8，具有256个引脚。AX301的资源包括逻辑单元、乘法器、RAM、IO口等。 流水灯实验： 我使用Quartus II软件编写了流水灯实验的Verilog代码。通过计数器对系统时钟进行计数，实现LED灯的循环点亮和熄灭。通过移位寄存器控制IO口的高低电平，改变LED的显示状态。 开发板下载流程： 编译Verilog代码并进行引脚分配。使用USB-Blaster下载文件到开发板。注意将sof文件转化为jic文件，以避免掉电丢失数据。 AX301开发板是学习FPGA的良好选择，流水灯实验帮助我更好地理解了FPGA开发和调试过程。 （心得体会的内容由newbing生成，望知悉） 实验二：数码管动态显示 一、实验目的 熟悉数码管动态显示原理 掌握组合电路和时序电路设计方法 二、实验内容及原理1. 实验内容两位数码管动态显示 2. 实验原理2.1. 硬件介绍开发板上安装了 6 个共阳数码管，可以显示 6 个数字(包含小数点) 。电路用 PNP 管来反向驱 动并且控制列扫描信号（SEL0_T~SEL5_T）来选择哪个数码管。而且所有的 6 个数码管的“段选信 号”（LEDA .. LEDH）都共用驱动引脚(LED_A~LEDH)。数码管的所有驱动信号都是“低电平有效”。 具体的原理图设计如下图所示: 2.2. 数码管扫描原理单个数码管可以采用静态显示方式，如图所示，数码管被分成 a、b、c、d、e、f、g 和小数 点，每段可以单独控制亮灭，通过点亮不同的段显示不同的数字和字符。 对于共阳极的数码管，显示数字和字符的编码如下： 对于多位数码管，利用视觉暂留原理，快速交替显示，让眼睛看上去是多个数码管同时显示的。 三、实验步骤及结果1. 程序设计本实验设计一个 2 位六十进制计数器模块（由一个十进制计数器和一个六进制计数器实现），然后通过译码模块译码后送到数码管扫描模块扫描显示。 2. 模块设计2.1. 译码模块主要作用是将二进制码转换成数码管的段控制信号。 2.2. 数码管扫描模块将多位数码管的段控制信号分时送出。 2.3. 模 10 计数器模块模块有同步复位，计数使能，进位输出功能，计数值从 0-9，并在等于 9 时进位。 2.4. 模 6 计数器模块模块有同步复位，计数使能，进位输出功能，计数值从 0-5，并在等于 5 时进位。 3. 实验结果 附：源程序代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134//seg_test.vmodule seg_test( input clk, input rst_n, output[5:0]seg_sel, output[7:0]seg_data ); reg[31:0] timer_cnt;reg en_1hz; //1 second , 1 counter enablealways@(posedge clk or negedge rst_n)begin if(rst_n == 1&#x27;b0) begin en_1hz &lt;= 1&#x27;b0; timer_cnt &lt;= 32&#x27;d0; end else if(timer_cnt &gt;= 32&#x27;d49_999_999) begin en_1hz &lt;= 1&#x27;b1; timer_cnt &lt;= 32&#x27;d0; end else begin en_1hz &lt;= 1&#x27;b0; timer_cnt &lt;= timer_cnt + 32&#x27;d1; endendwire[3:0] count0;wire t0;count_m10 count10_m0( .clk (clk), .rst_n (rst_n), .en (en_1hz), .clr (1&#x27;b0), .data (count0), .t (t0) );wire[3:0] count1;wire t1;count_m6 count6_m1( //oringin: count_m10 count10_m1 .clk (clk), .rst_n (rst_n), .en (t0), .clr (1&#x27;b0), .data (count1), .t (t1) ); wire[3:0] count2;wire t2;count_m10 count10_m2( .clk (clk), .rst_n (rst_n), .en (t1), .clr (1&#x27;b0), .data (count2), .t (t2)); wire[3:0] count3;wire t3;count_m10 count10_m3( .clk (clk), .rst_n (rst_n), .en (t2), .clr (1&#x27;b0), .data (count3), .t (t3)); wire[3:0] count4;wire t4;count_m10 count10_m4( .clk (clk), .rst_n (rst_n), .en (t3), .clr (1&#x27;b0), .data (count4), .t (t4)); wire[3:0] count5;wire t5;count_m10 count10_m5( .clk (clk), .rst_n (rst_n), .en (t4), .clr (1&#x27;b0), .data (count5), .t (t5)); wire[6:0] seg_data_0;seg_decoder seg_decoder_m0( .bin_data (count5), .seg_data (seg_data_0));wire[6:0] seg_data_1;seg_decoder seg_decoder_m1( .bin_data (count4), .seg_data (seg_data_1));wire[6:0] seg_data_2;seg_decoder seg_decoder_m2( .bin_data (count3), .seg_data (seg_data_2));wire[6:0] seg_data_3;seg_decoder seg_decoder_m3( .bin_data (count2), .seg_data (seg_data_3));wire[6:0] seg_data_4;seg_decoder seg_decoder_m4( .bin_data (count1), //attention, this is COUNT1 .seg_data (seg_data_4)); wire[6:0] seg_data_5;seg_decoder seg_decoder_m5( .bin_data (count0), .seg_data (seg_data_5)); seg_scan seg_scan_m0( .clk (clk), .rst_n (rst_n), .seg_sel (seg_sel), .seg_data (seg_data), .seg_data_4 (&#123;1&#x27;b1,seg_data_4&#125;), .seg_data_5 (&#123;1&#x27;b1,seg_data_5&#125;));endmodule 123456789101112131415161718192021222324252627282930313233343536373839//count_m10.vmodule count_m10( input clk, input rst_n, input en, //Counter enable input clr, //Counter synchronous reset output reg[3:0]data, //counter value output reg t // carry enable signal );always@(posedge clk or negedge rst_n) begin if(rst_n==0) begin data &lt;= 4&#x27;d0; t &lt;= 1&#x27;d0; end else if(clr) begin data &lt;= 4&#x27;d0; t &lt;= 1&#x27;d0; end else if(en) begin if(data==4&#x27;d9) begin t&lt;= 1&#x27;b1; //Counter to 9 to generate carry data &lt;= 4&#x27;d0;//Counter to 9 reset end else begin t &lt;= 1&#x27;b0; data &lt;= data + 4&#x27;d1; end end else t &lt;= 1&#x27;b0;end endmodule 123456789101112131415161718192021222324252627282930313233343536373839//count_m6.vmodule count_m6( input clk, input rst_n, input en, //Counter enable input clr, //Counter synchronous reset output reg[3:0]data, //counter value output reg t // carry enable signal );always@(posedge clk or negedge rst_n) begin if(rst_n==0) begin data &lt;= 4&#x27;d0; t &lt;= 1&#x27;d0; end else if(clr) begin data &lt;= 4&#x27;d0; t &lt;= 1&#x27;d0; end else if(en) begin if(data==4&#x27;d5) begin t&lt;= 1&#x27;b1; //Counter to 5 to generate carry data &lt;= 4&#x27;d0;//Counter to 5 reset end else begin t &lt;= 1&#x27;b0; data &lt;= data + 4&#x27;d1; end end else t &lt;= 1&#x27;b0;end endmodule 123456789101112131415161718192021222324252627282930//seg_decoder.vmodule seg_decoder( input[3:0] bin_data, // bin data input output reg[6:0] seg_data // seven segments LED output //origin: [6:0]); always@(*)begin case(bin_data) 4&#x27;d0:seg_data &lt;= 7&#x27;b100_0000; 4&#x27;d1:seg_data &lt;= 7&#x27;b111_1001; 4&#x27;d2:seg_data &lt;= 7&#x27;b010_0100; 4&#x27;d3:seg_data &lt;= 7&#x27;b011_0000; 4&#x27;d4:seg_data &lt;= 7&#x27;b001_1001; 4&#x27;d5:seg_data &lt;= 7&#x27;b001_0010; 4&#x27;d6:seg_data &lt;= 7&#x27;b000_0010; 4&#x27;d7:seg_data &lt;= 7&#x27;b111_1000; 4&#x27;d8:seg_data &lt;= 7&#x27;b000_0000; 4&#x27;d9:seg_data &lt;= 7&#x27;b001_0000; 4&#x27;ha:seg_data &lt;= 7&#x27;b000_1000; 4&#x27;hb:seg_data &lt;= 7&#x27;b000_0011; 4&#x27;hc:seg_data &lt;= 7&#x27;b100_0110; 4&#x27;hd:seg_data &lt;= 7&#x27;b010_0001; 4&#x27;he:seg_data &lt;= 7&#x27;b000_0110; 4&#x27;hf:seg_data &lt;= 7&#x27;b000_1110; default:seg_data &lt;= 7&#x27;b111_1111; endcaseendendmodule 四、实验中遇到的问题及解决方法问题数码管显示不完整 解决方案发现是因为修改代码的过程中把数码管段控制修改错误，应是seg_data_5和seg_data_6，错改成了1和2，改回来即可；以及修改过程中将管脚配置写错，改回默认即可。 五、心得体会通过本次实验，我深入理解了数码管的工作原理和动态扫描显示的实现方法。 我学会了如何在 FPGA 上设计和连接不同模块，实现复杂的功能。 首先，我们设计了一个十进制计数器模块，用于计时秒数。当计数到 9 时，它会自动清零并触发六进制计数器开始新一轮计数。 其次，我们实现了一个六进制计数器模块，用于计数分钟。当六进制计数器达到 6 时，它会自动清零，并通知译码模块开始新一轮计数。 我们使用了七段显示译码器，将计数器的输出转换为七段数码管的控制信号。 最后，我们编写了数码管扫描模块，控制数码管的显示。 我们成功地实现了一个 2 位六十进制计数器，可以准确地显示秒数和分钟数。 数码管的扫描显示效果流畅，没有闪烁或乱码。 通过这次实验，我不仅掌握了硬件描述语言的基本知识，还提高了问题解决能力。 我对 FPGA 的应用有了更深入的了解，希望在今后的学习和工作中能继续探索更多有趣的项目。 这次实验让我更加熟悉了数字电路设计和 FPGA 编程，也为我未来的职业发展打下了坚实的基础。 （心得体会由newbing生成，望知悉） 实验三：数字时钟设计 一、实验目的 掌握元件例化方法 掌握自上而下的电路设计方法 二、实验内容及原理1. 实验内容设计一个数字时钟，通过6个数码管分别显示小时、分钟和秒。 2. 实验原理2.1. 硬件介绍开发板上安装了 6 个共阳数码管，可以显示 6 个数字(包含小数点) 。电路用 PNP 管来反向驱 动并且控制列扫描信号（SEL0_T~SEL5_T）来选择哪个数码管。而且所有的 6 个数码管的“段选信 号”（LEDA .. LEDH）都共用驱动引脚(LED_A~LEDH)。数码管的所有驱动信号都是“低电平有效”。 具体的原理图设计如下图所示: 2.2. 数码管扫描原理单个数码管可以采用静态显示方式，如图所示，数码管被分成 a、b、c、d、e、f、g 和小数 点，每段可以单独控制亮灭，通过点亮不同的段显示不同的数字和字符。 对于共阳极的数码管，显示数字和字符的编码如下： 对于多位数码管，利用视觉暂留原理，快速交替显示，让眼睛看上去是多个数码管同时显示的。 三、实验步骤及结果1. 程序设计本实验设计一个 2 位60进制计数器模块（由一个十进制计数器和一个六进制计数器实现）和一个2位24进制计数器模块，然后通过译码模块译码后送到数码管扫描模块扫描显示。 2. 模块设计2.1. 译码模块主要作用是将二进制码转换成数码管的段控制信号。 2.2. 数码管扫描模块将多位数码管的段控制信号分时送出。 2.3. 模 10 计数器模块模块有同步复位，计数使能，进位输出功能，计数值从 0-9，并在等于 9 时进位。 2.4. 模 6 计数器模块模块有同步复位，计数使能，进位输出功能，计数值从 0-5，并在等于 5 时进位。 2.5. 模 24 计数器模块此模块右两部分构成，一部分是十位（count_m24_x）另一部分是个位（count_m24_y）。十位数字通过逢2进位实现24进制的“2”，个位数字通过两次十进制和一次五进制来实现24进制的“4”。 附：完整代码 123456// 此代码基于实验二的seg_test.v// 在实验二的seg_test.v的第129行后边插入以下代码： .seg_data_0 (&#123;1&#x27;b1,seg_data_0&#125;), //The decimal point at the highest bit,and low level effecitve .seg_data_1 (&#123;1&#x27;b1,seg_data_1&#125;), .seg_data_2 (&#123;1&#x27;b1,seg_data_2&#125;), .seg_data_3 (&#123;1&#x27;b1,seg_data_3&#125;), 123456789101112131415161718192021222324252627282930313233// 此代码基于实验二的seg_scan.v// 在实验二的seg_scan模块代码的基础上进行以下修改：// 在第5行后边插入： input[7:0] seg_data_0, input[7:0] seg_data_1, input[7:0] seg_data_2, input[7:0] seg_data_3, // 在第49行后边插入 //first digital led 4&#x27;d0: begin seg_sel &lt;= 6&#x27;b11_1110; seg_data &lt;= seg_data_0; end //second digital led 4&#x27;d1: begin seg_sel &lt;= 6&#x27;b11_1101; seg_data &lt;= seg_data_1; end //... 4&#x27;d2: begin seg_sel &lt;= 6&#x27;b11_1011; seg_data &lt;= seg_data_2; end 4&#x27;d3: begin seg_sel &lt;= 6&#x27;b11_0111; seg_data &lt;= seg_data_3; end 123456789101112131415161718192021222324252627282930313233343536373839//count_m24_x.vmodule count_m24_x( input clk, input rst_n, input en, //Counter enable input clr, //Counter synchronous reset output reg[3:0]data, //counter value output reg t // carry enable signal );always@(posedge clk or negedge rst_n) begin if(rst_n==0) begin data &lt;= 4&#x27;d0; t &lt;= 1&#x27;d0; end else if(clr) begin data &lt;= 4&#x27;d0; t &lt;= 1&#x27;d0; end else if(en) begin if(data==4&#x27;d2) begin t&lt;= 1&#x27;b1; //Counter to 2 to generate carry data &lt;= 4&#x27;d0;//Counter to 2 reset end else begin t &lt;= 1&#x27;b0; data &lt;= data + 4&#x27;d1; end end else t &lt;= 1&#x27;b0;end endmodule 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051//count_m24_y.vmodule count_m24_y( input clk, input rst_n, input en, //Counter enable input clr, //Counter synchronous reset output reg[3:0]data, //counter value output reg t // carry enable signal ); reg[3:0] y_timer; // 24_y timer always@(posedge clk or negedge rst_n)begin if(rst_n==0) begin data &lt;= 4&#x27;d0; t &lt;= 1&#x27;d0; y_timer &lt;= 4&#x27;d0; end else if(clr) begin data &lt;= 4&#x27;d0; t &lt;= 1&#x27;d0; y_timer &lt;= 4&#x27;d0; end else if(en) begin if(data==4&#x27;d9) begin t&lt;= 1&#x27;b1; //Counter to 9 to generate carry data &lt;= 4&#x27;d0;//Counter to 9 reset y_timer &lt;= y_timer + 4&#x27;d1; end else if(data==4&#x27;d3 &amp;&amp; y_timer==4&#x27;d2) begin t &lt;= 1&#x27;b1; data &lt;= 4&#x27;d0; y_timer &lt;= 4&#x27;d0; end else begin t &lt;= 1&#x27;b0; data &lt;= data + 4&#x27;d1; end end else t &lt;= 1&#x27;b0;end endmodule 然后，在seg_test.v里边，第89行的wire t3的count_m10改成count_m6，然后把第100行和111行的wire t4和wire t5的count_m10分别改为count_m24_y和count_m24_x即可实现。 四、实验中遇到的问题及解决方法其一时钟计数速度过慢（对于调试来说），解决方法是： 可以修改seg_test.v第45行的32&#39;d49_999_999为32&#39;d49_999，这样分钟的十位会按比秒稍微快一点的速度计数。 其二如何实现24进制： 由于时钟的每一位数字是单独控制的，所以24进制通过两个数字分别控制来实现，也就是一部分是十位（count_m24_x）另一部分是个位（count_m24_y）。十位数字通过逢2进位实现24进制的“2”，个位数字通过两次十进制和一次五进制来实现24进制的“4”。 五、心得体会这次的数字时钟设计实验是一个有趣且具有挑战性的任务。在设计过程中，我深刻体会到了模块化设计的重要性，以及如何将不同功能的模块协调工作。以下是我在这个实验中的一些感受： 模块化设计的优势： 通过将整个系统拆分为不同的模块，我们可以更好地管理复杂性。每个模块专注于特定的功能，使得代码更易于维护和调试。这次实验中，我学到了如何设计独立的计时模块和数码管显示模块，并将它们组合在一起。 时序控制的挑战： 在数码管显示模块中，动态扫描的时序控制是一个关键问题。我们需要确保数码管按照正确的顺序点亮，以显示出完整的时间。这让我意识到了时序设计的重要性，以及如何避免潜在的冲突。 仿真的重要性： 在设计过程中，我进行了详细的仿真测试。通过仿真，我能够观察到时、分、秒各自的跳变过程，并验证整点报时控制信号的正确性。这次实验让我明白了仿真在硬件设计中的关键作用。 （心得体会由newbing生成，望知悉） 实验四：正弦信号发生器设计 一、实验目的 掌握ROM存储器 IP核的使用 掌握IP核的仿真方法 掌握signal Tap嵌入式逻辑分析仪的使用方法 二、实验内容及原理1. 实验内容产生一定频率的正弦信号，信号频率可设置或选择 2. 实验原理首先是 FPGA 中的波形发生器控制电路，它通过外来控制信号和高速时钟 信号，向波形数据 ROM 发出地址信号。波形数据 ROM 中存有发生器的波形数据，如正弦 波或三角波数据。当接受来自 FPGA 的地址信号后，将从数据线输出相应的波形数据。 三、实验步骤及结果 打开 Quartus 软件，点击 File，找到并点击 New Project Wizard，新建工程。为工程命名， 选择 Cyclone IV E 器件，将管脚个数选为 256，速度选 8，然后选中器件栏中的第一行器件。 然后在界面的最右边 IP 核目录库下的 Basic Function 中找到 On Chip Memory，选择 ROM:1-PORT。然后出现一个窗口，为最后生成的文件命名，点击 OK。接着又出现一个界 面，主要是对 IP 核进行参数的设置，将位数设置为 8，将数据个数设置为 256 即可，点击 NEXT。在新出现的窗口中找到 Create a ‘rden’ read enable signal 打上对号，再点击 NEXT。 这时候需要添加存储器的初始化文件，注意该文件的后缀是.mif，然后继续往下进行，最后 结束。结束后又出现一个窗口，窗口主要是询问刚才生成的 IP 核文件是否加入工程里，点 击 YES，在当行窗口点击 Files 即可看到自动生成的文件。 使用 IP 核。新建文件，写入程序代码。具体代码如下: 12345678910111213141516171819202122//sinwave1.vmodule sinwave1(clk, rst_n, dout);input clk, rst_n;output [7:0] dout;reg [7:0] address;reg rden;always@(posedge clk or negedge rst_n)begin if (!rst_n) rden ≤0; else rden ≤1;endalways@(posedge clk or negedge rst_n)begin if (!rst_n) address≤0; else address ≤address+1;endmyrom1 u1(.address(address) ,.clock(clk) ,.rden(rden),.q(dout));endmodule 使用 Signal Tap Logic Analyzer File。点击 File—&gt;new—&gt;Signal Tap Logic Analyzer File—&gt;OK。在出现的界面做三个设置，第一个：双击空白窗口，在出现的窗口中 Filter 找到 Pins all 并点击选择，再点击 list，然后选择 dout—&gt;insert—&gt;closed；第二个：窗口右边找到 Clock—&gt;…—&gt;Filter—&gt;Pins all—&gt;list—&gt;clk—&gt;insert—&gt;OK；第三个：在右边窗口，找到 Sample depth 将其改为 1K，即可。然后保存。接着出现一个窗口提示是否把当前这个加入工程里， 点击 YES。再次编译。结果如下图示。 把电路板的与电脑连接。然后在刚才的界面右边找到 Hardware—&gt;USB-Blaster,然后选择 需要下载的文件，点击下载的图标，然后程序就下载进去了，接着点击运行，然后波形就出现了。右键点击 dout[7:0]—&gt;Bus Display Format—&gt;Unsigned Line Chart， 即可看到正弦波，如下图示。 四、实验中遇到的问题及解决方法遇到的问题主要在于软件使用上的操作问题，经过点击不同的位置试错之后解决问题。 五、心得体会我将波形数据存入FPGA的ROM中，同时在FPGA中实现了外部控制逻辑单元，通过仿真测试，我成功地实现了正弦信号发生器的设计要求。这次实验让我更深入地理解了数字电路设计和信号处理的原理。 实验五：任意波形发生器设计 一、实验目的 熟练掌握IP核的使用 掌握自上而下的电路设计方法 二、实验内容及原理1. 实验内容 生成4种基本波形，例如正弦波、方波等，具体波形和参数自定。 输出4种基本波形的任意叠加结果，共16种波形可供选择。 2. 实验原理 模块输入和输出： 输入：时钟信号clk和复位信号rst。 输出：共有15个输出信号，分别是q1到q15，它们的位宽分别为8位到11位。 寄存器address： 定义了一个9位宽的寄存器address，用于存储地址信息。 在每个时钟下降沿或复位信号下降沿时，根据复位状态更新 address 的值。 四个ROM模块： sinewave、fangbo、jvchibo和sanjiaobo是四个 ROM 模块。 每个模块都有相同的输入信号address和时钟信号clk，以及不同的输出信号q1、q2、q3和q4。 这些模块根据给定的地址从ROM中读取数据，并将结果存储在相应的输出信号中。 输出信号的计算： q5到q15是通过对输入信号q1、q2、q3和q4进行不同的运算得到的。 例如，q5是q1和q2的和，q6是q1和q3的和，以此类推。 总之，这段代码实现了一个多输出的模块，其中包含了四个ROM模块和一些逻辑运算。每个ROM模块根据地址从ROM中读取数据，并将结果存储在相应的输出信号中。 （实验原理部分的内容由newbing生成，望知悉） 三、实验步骤及结果 新建工程与波形文件生成不再赘述，之前实验中已经说明。 在IP核库里的Basic Function – On Chip Memory，选择ROM:1-PORT，为每一个波形对应的实例化ROM核命名，比如本程序里将正弦波对应的ROM核命名为“sinewave”，对应的就是“sinewave.qip”和“sinewave.v”，然后一直点next，在需要选择波形文件以进行初始化时选择在步骤0中生成的正弦波文件，然后继续next。最后在询问是否将刚才生成的IP核加入工程的窗口点击YES，这样即可在Files里看到刚刚生成的文件，如Fig-1所示。 重复步骤1，将另外的三个波形也写入ROM核。 编写顶层文件，完整代码如下。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667//hechengbo.vmodule hechengbo( input clk, input rst, output [7:0] q1, output [7:0] q2, output [7:0] q3, output [7:0] q4, output [8:0] q5, output [8:0] q6, output [8:0] q7, output [8:0] q8, output [8:0] q9, output [8:0] q10, output [9:0] q11, output [9:0] q12, output [9:0] q13, output [9:0] q14, output [10:0] q15 );reg [8:0] address; always @ (negedge clk or negedge rst)begin if(!rst) address &lt;= 1&#x27;b0; else address &lt;= address+1&#x27;b1;endsinewave ROM_1( .address(address), .clock (clk), .q (q1));fangbo ROM_2( .address(address), .clock (clk), .q (q2));jvchibo ROM_3( .address(address), .clock (clk), .q (q3));sanjiaobo ROM_4( .address(address), .clock (clk), .q (q4));assign q5=q1+q2;assign q6=q1+q3;assign q7=q1+q4;assign q8=q3+q2;assign q9=q4+q2;assign q10=q1+q3+q4;assign q11=q1+q2+q3;assign q12=q1+q2+q4;assign q13=q2+q3+q4;assign q14=q3+q4;assign q15=q1+q2+q3+q4;endmodule 使用 Signal Tap Logic Analyzer File。点击 File—&gt;new—&gt;Signal Tap Logic Analyzer File—&gt;OK。在出现的界面做两个设置，第一个：双击空白窗口，在出现的窗口中 Filter 找到 Pins all 并点击选择，再点击 list，然后选择 q1~q15—&gt;insert—&gt;closed；第二个：窗口右边找到 Clock—&gt;…—&gt;Filter—&gt;Pins all—&gt;list—&gt;clk—&gt;insert—&gt;OK。然后保存。接着出现一个窗口提示是否把当前这个加入工程里， 点击 YES。编译。结果如下图示。 把电路板的与电脑连接。然后在刚才的界面右边找到 Hardware—&gt;USB-Blaster,然后选择 需要下载的文件，点击下载的图标，然后程序就下载进去了，接着点击运行，然后波形就出现了。按ctrl+A全选节点q1~q15—&gt;Bus Display Format—&gt;Unsigned Line Chart，即可看到q1~q4四个基本波形以及q5~q15的波形合成结果，如下图示。 四、实验中遇到的问题及解决方法Signal Tap运行之后看不到波形，看到的不是正弦形状等。解决方法就是Bus Display Format—&gt;Unsigned Line Chart，将波形显示模式改为Line Chart。 五、心得体会学到了一些逻辑运算，以下是一些常见的逻辑运算： 与运算（AND）： AND 运算将两个输入值进行比较，如果两者都为真，则结果为真；否则，结果为假。 例如，如果输入 A 和输入 B 都为真，那么 A AND B 的结果为真。 或运算（OR）： OR 运算将两个输入值进行比较，如果其中至少一个为真，则结果为真；否则，结果为假。 例如，如果输入 A 或输入 B 中至少有一个为真，那么 A OR B 的结果为真。 非运算（NOT）： NOT 运算将单个输入值进行比较，如果输入为真，则结果为假；如果输入为假，则结果为真。 例如，如果输入 A 为真，那么 NOT A 的结果为假。 异或运算（XOR）： XOR 运算也称为“互斥或”运算。它将两个输入值进行比较，如果两者不相等，则结果为真；如果两者相等，则结果为假。 例如，如果输入 A 和输入 B 不相等，那么 A XOR B 的结果为真。 学到了如何进行波的叠加运算。 （心得体会由newbing生成，望知悉） 实验六：硬件消抖电路设计 一、实验目的 熟悉硬件消抖原理 熟悉状态机的设计方法 二、实验内容及原理1. 实验内容：每按一次按键，数码管显示的60进制计数结果加1 2. 实验原理:（此部分内容由newbing生成，望知悉） 顶层文件key_debounce模块 模块输入和输出： 输入：时钟信号 clk、复位信号 rst_n 和按键输入信号 key1。 输出：6 位选择信号 seg_sel 和 8 位的七段显示数据信号 seg_data。 按键去抖动逻辑： 使用 ax_debounce 模块对输入的按键信号 key1 进行去抖动处理。 button_negedge 是检测到按键下降沿的信号。 去抖动后的输出作为计数器的使能信号。 两个计数器： count10_m0 和 count10_m1 是两个 4 位计数器。 count10_m0 在去抖动后的按键下降沿触发，用于计数按键按下的次数。 count10_m1 在 t0（从 count10_m0 得到的进位信号）为高电平时触发，用于进一步计数。 计数器值解码： 两个 seg_decoder 模块将计数器的值（count 和 count1）解码为 7 段显示数据。 解码后的数据存储在 seg_data_0 和 seg_data_1 中。 7 段扫描： seg_scan 模块扫描 7 段显示。 它选择六个段之一（由 seg_sel 控制），并提供相应的数据（seg_data）。 按键消抖ax_debounce模块： 模块输入和输出： 输入：时钟信号 clk、复位信号 rst 和按键输入信号 button_in。 输出：去抖动后的按键信号 button_out，以及按键上升沿和下降沿的标志 button_posedge 和 button_negedge。 内部常数和变量： N：去抖动计时器的位宽。 FREQ：模型时钟频率（以 MHz 为单位）。 MAX_TIME：最大去抖动时间（以毫秒为单位）。 TIMER_MAX_VAL：计时器的最大值，根据最大去抖动时间计算得出。 计时器控制： q_reset：通过异或运算检测输入翻转，用于重置计时器。 q_add：当 q_reg 的最高位为 0 时，允许计数器增加。 计数器逻辑： q_next：根据 q_reset 和 q_add 计算下一个计数器值。 DFF1 和 DFF2：输入的触发器。 q_reg：计数器的当前值。 按键输出控制： button_out：在计数器达到最大值时，将按键输出设置为 DFF2 的值。 button_out_d0：按键输出的初始值。 button_posedge 和 button_negedge：用于检测按键上升沿和下降沿。 4位6进制计数器count_m6模块 模块输入和输出： 输入：时钟信号 clk、复位信号 rst_n、计数器使能信号 en 和同步清零信号 clr。 输出：4 位计数器值 data 和进位使能信号 t。 计数器逻辑：在时钟上升沿或复位信号下降沿时，执行以下操作： 如果复位信号 rst_n 为低电平（0），则将计数器值 data 和进位使能信号 t 都重置为 0。 如果同步清零信号 clr 为高电平（1），也将计数器值 data 和进位使能信号 t 都重置为 0。 如果计数器使能信号 en 为高电平（1）： 如果计数器值 data 等于 5，将进位使能信号 t 设置为 1（用于产生进位）并将计数器值 data 重置为 0。 否则，将进位使能信号 t 设置为 0，计数器值 data 加 1。 否则，将进位使能信号 t 设置为 0。 计数器行为： 计数器从 0 开始计数，每次递增 1。 当计数器值达到 5 时，产生进位信号 t 并将计数器值重置为 0。 4位10进制计数器count_m10模块 原理与上边的6进制计数器一样，只是进位的数字不一样。 解码模块seg_decoder，用于将 4 位二进制输入 bin_data 解码为七段显示的输出 seg_data always 块： 这个模块中的 always 块是组合逻辑，它在任何输入变化时都会执行。 always @(*) 表示敏感于所有输入信号的变化。 case 语句： case(bin_data) 根据输入的 bin_data 的值进行匹配。 对于每个可能的 bin_data 值，都有一个对应的七段显示模式。 七段显示模式： 七段显示器通常由 7 个段（a、b、c、d、e、f、g）组成，每个段可以点亮或熄灭。 在这里，七段显示的每个段用一个位表示，其中 1 表示点亮，0 表示熄灭。 每个 seg_data 的 7 位对应于 a、b、c、d、e、f、g 段的状态。 具体的解码： 例如，当 bin_data 为 4’d0（表示十进制 0）时，seg_data 被设置为 7’b100_0000（点亮 a 段，其他段熄灭，显示数字 0）。 类似地，对于其他的 bin_data 值，都有相应的七段显示模式。 默认情况： 如果 bin_data 的值不在 0 到 15 之间，default 分支将 seg_data 设置为 7’b111_1111（所有段都熄灭）。 扫描模块seg_scan，用于控制七段显示器的扫描 模块输入和输出： 输入：时钟信号 clk、复位信号 rst_n 和六个七段显示器的数据信号 seg_data_0 到 seg_data_5。 输出：6 位选择信号 seg_sel 和 8 位的七段显示数据信号 seg_data。 计时器和选择逻辑： scan_timer 是一个 32 位计时器，用于控制扫描的时间。 scan_sel 是一个 4 位计数器，用于选择要扫描的七段显示器。 计时器和选择逻辑的实现： 在时钟上升沿或复位信号下降沿时，执行以下操作： 如果复位信号 rst_n 为低电平（0），则重置计时器和选择计数器。 如果计时器达到预定的扫描周期（SCAN_COUNT），则重置计时器并更新选择计数器。 否则，继续递增计时器。 七段显示器选择和数据输出： 根据选择计数器的值，选择要扫描的七段显示器。 每个选择对应一个七段显示器的段选信号 seg_sel 和相应的数据 seg_data。 例如，当 scan_sel 为 4’d0 时，选择第一个七段显示器，设置 seg_sel 为 6’b11_1110，并将 seg_data 设置为 seg_data_0。 默认情况： 如果选择计数器的值不在 0 到 5 之间，将 seg_sel 设置为 6’b11_1111，并将 seg_data 设置为 8’hff（所有段都熄灭）。 三、实验步骤及结果编写程序代码编译即可。各模块代码按照实验原理中的模块顺序依次如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364//key_debounce.vmodule key_debounce( input clk, input rst_n, input key1, output [5:0] seg_sel, output [7:0] seg_data);wire button_negedge; //Key falling edgeax_debounce ax_debounce_m0( .clk (clk), .rst (~rst_n), .button_in (key1), .button_posedge (), .button_negedge (button_negedge), .button_out ());wire[3:0] count;wire t0;count_m10 count10_m0( .clk (clk), .rst_n (rst_n), .en (button_negedge), .clr (1&#x27;b0), .data (count), .t (t0));wire[3:0] count1;wire t1;count_m6 count10_m1( .clk (clk), .rst_n (rst_n), .en (t0), .clr (1&#x27;b0), .data (count1), .t (t1));//Count decodingwire[6:0] seg_data_0;seg_decoder seg_decoder_m0( .bin_data (count), .seg_data (seg_data_0));wire[6:0] seg_data_1;seg_decoder seg_decoder_m1( .bin_data (count1), .seg_data (seg_data_1));seg_scan seg_scan_m0( .clk (clk), .rst_n (rst_n), .seg_sel (seg_sel), .seg_data (seg_data), .seg_data_0 (&#123;1&#x27;b1,7&#x27;b1111_111&#125;), .seg_data_1 (&#123;1&#x27;b1,7&#x27;b1111_111&#125;), .seg_data_2 (&#123;1&#x27;b1,7&#x27;b1111_111&#125;), .seg_data_3 (&#123;1&#x27;b1,7&#x27;b1111_111&#125;), .seg_data_4 (&#123;1&#x27;b1,seg_data_1&#125;), .seg_data_5 (&#123;1&#x27;b1,seg_data_0&#125;));endmodule 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586//ax_debounce.v`timescale 1 ns / 100 psmodule ax_debounce ( input clk, input rst, input button_in, output reg button_posedge, output reg button_negedge, output reg button_out);//// ---------------- internal constants --------------parameter N = 32 ; // debounce timer bitwidthparameter FREQ = 50; //model clock :Mhzparameter MAX_TIME = 20; //mslocalparam TIMER_MAX_VAL = MAX_TIME * 1000 * FREQ;////---------------- internal variables ---------------reg [N-1 : 0] q_reg; // timing regsreg [N-1 : 0] q_next;reg DFF1, DFF2; // input flip-flopswire q_add; // control flagswire q_reset;reg button_out_d0;//// ------------------------------------------------------////contenious assignment for counter controlassign q_reset = (DFF1 ^ DFF2); // xor input flip flops to look for level chage to reset counterassign q_add = ~(q_reg == TIMER_MAX_VAL); // add to counter when q_reg msb is equal to 0 //// combo counter to manage q_next always @ ( q_reset, q_add, q_reg)begin case( &#123;q_reset , q_add&#125;) 2&#x27;b00 : q_next &lt;= q_reg; 2&#x27;b01 : q_next &lt;= q_reg + 1; default : q_next &lt;= &#123; N &#123;1&#x27;b0&#125; &#125;; endcase end//// Flip flop inputs and q_reg updatealways @ ( posedge clk or posedge rst)begin if(rst == 1&#x27;b1) begin DFF1 &lt;= 1&#x27;b0; DFF2 &lt;= 1&#x27;b0; q_reg &lt;= &#123; N &#123;1&#x27;b0&#125; &#125;; end else begin DFF1 &lt;= button_in; DFF2 &lt;= DFF1; q_reg &lt;= q_next; endend//// counter controlalways @ ( posedge clk or posedge rst)begin if(rst == 1&#x27;b1) button_out &lt;= 1&#x27;b1; else if(q_reg == TIMER_MAX_VAL) button_out &lt;= DFF2; else button_out &lt;= button_out;endalways @ ( posedge clk or posedge rst)begin if(rst == 1&#x27;b1) begin button_out_d0 &lt;= 1&#x27;b1; button_posedge &lt;= 1&#x27;b0; button_negedge &lt;= 1&#x27;b0; end else begin button_out_d0 &lt;= button_out; button_posedge &lt;= ~button_out_d0 &amp; button_out; button_negedge &lt;= button_out_d0 &amp; ~button_out; end endendmodule 123456789101112131415161718192021222324252627282930313233343536373839//count_m6.vmodule count_m6( input clk, input rst_n, input en, //Counter enable input clr, //Counter synchronous reset output reg[3:0]data, //counter value output reg t // carry enable signal );always@(posedge clk or negedge rst_n) begin if(rst_n==0) begin data &lt;= 4&#x27;d0; t &lt;= 1&#x27;d0; end else if(clr) begin data &lt;= 4&#x27;d0; t &lt;= 1&#x27;d0; end else if(en) begin if(data==4&#x27;d5) begin t&lt;= 1&#x27;b1; //Counter to 5 to generate carry data &lt;= 4&#x27;d0;//Counter to 5 reset end else begin t &lt;= 1&#x27;b0; data &lt;= data + 4&#x27;d1; end end else t &lt;= 1&#x27;b0;endendmodule 123456789101112131415161718192021222324252627282930313233343536373839//count_m10.vmodule count_m10( input clk, input rst_n, input en, //Counter enable input clr, //Counter synchronous reset output reg[3:0]data, //counter value output reg t // carry enable signal );always@(posedge clk or negedge rst_n) begin if(rst_n==0) begin data &lt;= 4&#x27;d0; t &lt;= 1&#x27;d0; end else if(clr) begin data &lt;= 4&#x27;d0; t &lt;= 1&#x27;d0; end else if(en) begin if(data==4&#x27;d9) begin t&lt;= 1&#x27;b1; //Counter to 9 to generate carry data &lt;= 4&#x27;d0;//Counter to 9 reset end else begin t &lt;= 1&#x27;b0; data &lt;= data + 4&#x27;d1; end end else t &lt;= 1&#x27;b0;endendmodule 123456789101112131415161718192021222324252627282930//seg_decoder.vmodule seg_decoder( input[3:0] bin_data, // bin data input output reg[6:0] seg_data // seven segments LED output);always@(*)begin case(bin_data) 4&#x27;d0:seg_data &lt;= 7&#x27;b100_0000; 4&#x27;d1:seg_data &lt;= 7&#x27;b111_1001; 4&#x27;d2:seg_data &lt;= 7&#x27;b010_0100; 4&#x27;d3:seg_data &lt;= 7&#x27;b011_0000; 4&#x27;d4:seg_data &lt;= 7&#x27;b001_1001; 4&#x27;d5:seg_data &lt;= 7&#x27;b001_0010; 4&#x27;d6:seg_data &lt;= 7&#x27;b000_0010; 4&#x27;d7:seg_data &lt;= 7&#x27;b111_1000; 4&#x27;d8:seg_data &lt;= 7&#x27;b000_0000; 4&#x27;d9:seg_data &lt;= 7&#x27;b001_0000; 4&#x27;ha:seg_data &lt;= 7&#x27;b000_1000; 4&#x27;hb:seg_data &lt;= 7&#x27;b000_0011; 4&#x27;hc:seg_data &lt;= 7&#x27;b100_0110; 4&#x27;hd:seg_data &lt;= 7&#x27;b010_0001; 4&#x27;he:seg_data &lt;= 7&#x27;b000_0110; 4&#x27;hf:seg_data &lt;= 7&#x27;b000_1110; default:seg_data &lt;= 7&#x27;b111_1111; endcaseendendmodule 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293//seg_scan.vmodule seg_scan( input clk, input rst_n, output reg[5:0] seg_sel, //digital led chip select output reg[7:0] seg_data, //eight segment digital tube output,MSB is the decimal point input[7:0] seg_data_0, input[7:0] seg_data_1, input[7:0] seg_data_2, input[7:0] seg_data_3, input[7:0] seg_data_4, input[7:0] seg_data_5);parameter SCAN_FREQ = 200; //scan frequencyparameter CLK_FREQ = 50000000; //clock frequencyparameter SCAN_COUNT = CLK_FREQ /(SCAN_FREQ * 6) - 1;reg[31:0] scan_timer; //scan time counterreg[3:0] scan_sel; //Scan select counteralways@(posedge clk or negedge rst_n)begin if(rst_n == 1&#x27;b0) begin scan_timer &lt;= 32&#x27;d0; scan_sel &lt;= 4&#x27;d0; end else if(scan_timer &gt;= SCAN_COUNT) begin scan_timer &lt;= 32&#x27;d0; if(scan_sel == 4&#x27;d5) scan_sel &lt;= 4&#x27;d0; else scan_sel &lt;= scan_sel + 4&#x27;d1; end else begin scan_timer &lt;= scan_timer + 32&#x27;d1; endendalways@(posedge clk or negedge rst_n)begin if(rst_n == 1&#x27;b0) begin seg_sel &lt;= 6&#x27;b111111; seg_data &lt;= 8&#x27;hff; end else begin case(scan_sel) //first digital led 4&#x27;d0: begin seg_sel &lt;= 6&#x27;b11_1110; seg_data &lt;= seg_data_0; end //second digital led 4&#x27;d1: begin seg_sel &lt;= 6&#x27;b11_1101; seg_data &lt;= seg_data_1; end //... 4&#x27;d2: begin seg_sel &lt;= 6&#x27;b11_1011; seg_data &lt;= seg_data_2; end 4&#x27;d3: begin seg_sel &lt;= 6&#x27;b11_0111; seg_data &lt;= seg_data_3; end 4&#x27;d4: begin seg_sel &lt;= 6&#x27;b10_1111; seg_data &lt;= seg_data_4; end 4&#x27;d5: begin seg_sel &lt;= 6&#x27;b01_1111; seg_data &lt;= seg_data_5; end default: begin seg_sel &lt;= 6&#x27;b11_1111; seg_data &lt;= 8&#x27;hff; end endcase endendendmodule 运行结果： 实际结果就是每按一次按键，数码管上的数字+1。 四、实验中遇到的问题及解决方法这次实验采用了demo中的按键消抖解决方案，并未遇到什么问题。 五、心得体会按键去抖动的原理： 按键在物理上按下或释放时，可能会产生多个电平变化，导致微小的抖动。 去抖动的目标是确保只有一个有效的按键状态被记录，而不受抖动的影响。 硬件去抖动： 硬件去抖动通常使用 RC 电路或者 Schmitt 触发器来实现。 RC 电路通过电容和电阻的组合，延迟电平变化，从而减少抖动。 Schmitt 触发器具有两个阈值电平，可以有效地抑制抖动。 软件去抖动： 软件去抖动通常在数字电路中使用。 我们可以使用计数器来跟踪按键状态的持续时间，只有在一定时间内保持稳定状态时才认为按键有效。 这需要合理的计时器设计和状态机控制。 Verilog HDL 中的实现： 在 Verilog HDL 中，我们可以使用 always 块来实现按键去抖动逻辑。 计数器、状态机和选择逻辑都可以在 Verilog 中方便地实现。 （心得体会由newbing生成，望知悉）"},{"path":"/2024/05/23/Multipass安装与使用中遇到的问题的一些记录/","content":"按时间顺序记录首先是Multipass的安装（在这之前我应该已经安装又卸载过十几次），参考的教程为：轻量虚拟机 Multipass 的部署和使用 一、部署 在window环境下进行部署，下载最新安装包后别着急执行，先进行multipass数据目录的配置： 以管理身份运行powershell：输入以下命令： 1Set-ItemProperty -Path &quot;HKLM:System\\CurrentControlSet\\Control\\Session Manager\\Environment&quot; -Name MULTIPASS_STORAGE -Value &quot;E:\\MultipassData&quot; 运行下载的可执行文件，选择自定义目录安装。 安装完成后查看版本： 打开任意 Windows 命令行，键入命令查看版本 1multipass --version 二、创建运行 ubuntu 实例 设置客户端口令，然后通过 命令查看支持的镜像列表： 设置口令：设置multipass的口令为 multipass（原文有这个，但是其实我不知道有什么用，感觉多此一举） 1multipass set local.passphrase=multipass 通过命令查看支持的镜像列表（这个无所谓） 1multipass find 通过命令创建实例（这里我的实例名用的是rimrose）： 1multipass launch -n rimrose -c 4 -m 8G -d 64G -n, –name: 名称 -c, –cpus: cpu 核心数, 默认: 1 -m, –mem: 内存大小, 默认: 1G -d, –disk: 硬盘大小, 默认: 5G 不知道为什么，出现问题了（明明之前装了几次都没出现这样的问题）： 我怀疑是Hyper-V的问题，查看一下设置 -&gt; 系统 -&gt; 可选功能 -&gt; 更多Windows功能 -&gt; Hyper-V 但是这里Hyper-V是打开了的 那先跳过这里，尝试一下再次安装 还是出现了问题： 我选择把软件卸载重装 使用GeekUninstaller卸载掉Multipass（这个软件会扫描文件和注册表的残留） 然后右键管理员运行multipass-1.13.0+win-win64.exe，进行一个安装。这次安装过程中没有报错（上一次装的时候中间弹出一条我没看明白的Error） 那么按照上边的步骤再次进行部署——然后又报错了，不过这个报错和上边这个很像 这个时候我才注意到这个8192MB什么什么RAM，很明显是内存不够，这里放一下我电脑的内存使用情况 （尴尬的笑） 然后我把内存改成4G就装上去了 通过命令查看运行的实例： 1multipass list 在开始 -&gt; 所有应用中找到multipass点击启动，然后就可以在任务栏看到图标 看到这个界面，点击Open Shell即可打开Ubuntu的终端。 到这里为止，Multipass的安装就完成了 时候不早了，先关机，第二天有空再继续（这点其实很重要，因为涉及到重启系统，指不定第二天开机会遇到什么奇葩问题） —————————————分界线————————————— 现在是2024.2.6，刚刚开机又出现下边的问题（说“又”是因为之前的十几次安装中我已经遇到过这个问题） 然后我右键看到这个界面之后不久，应用图标消失了（？） 在PowerShell里输入multipass list，显示如下： 再次点击应用图标启动软件，依然会出现Failure retrieving instances的问题 现在是2024.2.12，不知道为什么，我的虚拟机突然能运行了；在这之前，也就是6号第一次重新开机到现在为止的时间段里边，每次开机都是Failure retrieving instances 所以趁着它能跑起来，我先把需要的东西给弄了，比如ros2（主要是想试着搞一下这篇博文里的东西 https://blog.csdn.net/weixin_44827364/article/details/104156116?spm=1001.2014.3001.5506 ） 成功了 不过用ros2需要GUI，所以下边装一下（参考 https://www.cnblogs.com/taylorshi/p/16039901.html ） 先更新一下包索引：1sudo apt-get update 接下来开启安装 1sudo apt-get install ubuntu-desktop xrdp -y 这将一次性安装ubuntu-desktop和xrdp两个软件 稍等片刻之后，安装完成 接下来创建一个登录用户名用来登录桌面 1sudo adduser $userName 并且给这个用户赋予访问权限 1sudo usermod -aG sudo $userName 然后获取当前Ubuntu实例IP，在PowerShell中输入 1multipass list 可以看到这里的ip是172.19.113.37（在Ubuntu的命令行里输入ip a也可以看到） 通过RDP客户端远程Ubuntu 用windows自带的搜索来搜索远程，找到远程桌面连接 打开它，输入刚才的IP地址，点击连接，在弹出的对话框选择是，这时我们可以看到一个登录对话框 输入之前设定的用来登录桌面的用户名和密码，然后点击OK 这样我们就看到了Ubuntu的桌面引导，说明我们已经来到桌面了 等待软件更新 这就是真正的Ubuntu桌面了，这太酷了 不过这时候有个问题，在这个用户下使用不了ros2命令，也许是因为ros2安装位置不在这个用户的目录下，而且不互通 所以在这个用户下再次安装一遍ros2 到这里先告一段落，因为博主出去玩了，而且电脑已经三天没关了，我打算尝试一下先关闭multipass再关机，看下次开机会不会再出错 右键点击任务栏中的multipass图标，选中正在运行的虚拟机，点击Stop 等待主机名称后边的Running消失后再点击Quit 然后关机 现在是2024.2.14，很不幸，再次出现了Failure retrieving instances的错误 现在我做一个大胆的猜想，会不会是multipass开机自启造成了这样的问题？所以试着把它的自启动关掉 下次开机再说吧 现在是2024.2.15，开机之后我点应用图标启动multipass，但还是出现了Failure retrieving instances的错误 现在是2024.2.20，刚刚我突然想用wallpaper engine，但是打开的时候有一个这样的提示： 提示说的没问题，我切到某几张视频壁纸的时候就无法播放了，很难受；这时候我觉得我之前搞得什么虚拟机啥的（还有别的软件或者系统本身）在使用过程中遇到各种奇怪的bug，也许和Windows的insider版本有关系，所以我决定从insider版本切换回稳定版 快进了一下，现在是2024.2.21的下午，我凌晨一点把系统重装回了win11稳定版，现在的系统信息如下 本来想着说下午直接装个Ubuntu实体机的，但是感觉有点麻烦，先搞一下multipass试试 （此处省略一大堆步骤） 这里我又觉得multipass不如实体机来的方便，所以决定先搞实体机 现在是2024.2.21，晚上的23：21，我把ubuntu实体机装好了，不需要虚拟机了（墨镜） To be continued —&gt; 遇到的问题01系统重启后遇到下边的情况：Failure retrieving instances Google了一下解决方案，在 https://github.com/canonical/multipass/issues/2223 这里找到了答案。 在终端里输入 1Get-CimInstance Win32_ComputerSystem | Select-Object -ExpandProperty HypervisorPresent 出现True，然后再输入 1Enable-WindowsOptionalFeature -Online -FeatureName Microsoft-Hyper-V -All 等待进度条走满，输入yes确认重启，之后就打开了 但是又遇到问题了，这个虚拟机点击了start之后会变成unknown state。这时点击Quit，并且在任务管理器找到multipassd.exe，结束任务，再以管理员身份打开cmd，输入multipassd，这时在PowerShell里输入multipass list，可以看到有虚拟机，但是状态依然是unknown。这时关闭cmd，进程multipass.exe也随之关闭，在PowerShell里输入multipass list也看不到东西，会输出list failed: cannot connect to the multipass socket。这时点击multipass的应用图标打开软件，会发现再次出现错误Failure retrieving instances。"},{"path":"/2024/05/23/About_me/","content":"About me你好，这里是筱荷，坐标郑州，电子信息大二学生，生理性别男，水瓶座ESFP 成分一览一般普通音游人/摄影爱好者/尼康Nikon/音乐爱好者/chilichill狂热粉丝/自然科学爱好者/羽球爱好者/明日方舟/稀音单推人/火西肆单推人/神乐七奈单推人/ESFP/wota艺初心者 音游成分主要玩maimai（写这个的时候是舞萌2023 rating 14160，主要追求准度和听歌）和pjsk（能fc一点红30和紫30的水平），也玩Phigros（rks14.85）、喵斯、Arcaea，偶尔打打Orzmic、中二；其他的音游多多少少都玩过一些，不过都不厉害 2023音游年度总结：鉴定为玩音游玩的 摄影方面是尼康佬，摄影是兴趣使然，平常拍的照片一般会发到这个相册里边 → qq空间相册：随便拍拍 照片方面不只拍风光，人像也会拍一些；修图的话比较擅长风光，目前人像修图技术还不太行；下边是我拍的一些东西 还有很多放不下的，感兴趣的话可以点下边的链接查看 2022/6/30—2023/5/23 用尼康Z5拍照的一年（图文版） 2022/6/30—2023/5/23 用尼康Z5拍照的一年（视频版） 2023摄影年度总结：摄影佬也要有自己的摄影年度总结 视频方面，有那么一点点帮别人录舞的经验，以及一点点剪辑经验 二刺螈成分&amp;其他 关于推/厨 明日方舟：稀音厨，手里有一些稀音的谷子（官方也没出几个啊啊啊啊啊），还有一个粘土人，偶尔会带出去拍照，还有一套cos服，少数时候会穿去漫展；阿米娅、陈sir、小羊、梅尔、森蚺、霞光什么的也喜欢（你们都是博士的翅膀啊.jpg） PJSK：25时团推，全员中最喜欢白葱（上边图里的小mzk是朋友送的）；说到这不得不提初音未来这个大坑，我真的不是推初音未来，只是因为她的谷子太好看了我才买的（真的） maimai：最喜欢盐巴（ソルト） EVA：绫波丽天下第一 （目前能想到的就这么多了） 其他二次元成分包括但不仅限于龙女仆、埃罗芒阿、五六七、五等份新娘、约定的梦幻岛、jojo、魔女之旅、辉夜、工作细胞、四谎；最近在追芙莉莲动画，漫画也有在看 关于vtuber/vup以前看狗妈多一点，不过后边播的少了就没怎么看了，但是对七奈的喜欢还在，上边图里左边蓝色的专辑就是证明（不过以后可能不会买别的周边了）；后来火西肆看的比较多，主要是喜欢听她唱歌，真的太好听了，非常戳我，简直是天籁；不过后来火西肆毕业之后由于一些原因就没怎么看过v了，现在属于是不看v的状态 听歌方面 ChiliChill：本人是chilichill激推，中文歌我现在基本上只听chilichill，只要你也听chilichill的歌我们就是好朋友！《每到夜里我就很饿》和《半梦半醒》两张专辑我都有买；2023年由于一些原因没去成线下live，目前还在期待今年线下live的信息 ボカロ：本人听术力口比较博爱，我觉得好听的就都听都喜欢；硬要说的话，最喜欢的曲子是ジャンキーナイトタウンオーケストラ（瘾者之夜城镇乐队）和妄想感傷代償連盟 真夜中：很喜欢ZTMY的歌，尤其喜欢曲子里的bass部分，比如灰心感和残机；好想去真夜中的演唱会 ツユ：早在三年前就听过他们的歌，当时没有太在意，去年因为打舞萌又听到了tuyu的歌，重新喜欢上了，真的太好听了 火西肆：被她的声音吸引住了，我真的超级喜欢她的歌声，虽然前边说不看她的直播了，但是她的翻唱还是有在听的，尤其是遇到烦心事的时候听她的歌会很让我安心 我的自设自设叫林筱荷，是龙门女大学生，长这样： 非音游的游戏之前不打音游的时候主要玩FPS（逆战十年老玩家），现在玩得少，APEX、战地5、彩六、csgo都玩一点；其他的游戏包括但不仅限于P5R、死亡细胞、泰拉瑞亚、mhw、碧蓝幻想relink、古墓丽影、刺客信条、ttf2、奥日、炉石（娱乐玩家，喜欢玩脏牧，国服没了之后就不玩了） wota艺方面去年暑假刚刚开始学打艺，还是个初心者，偶尔会在b站发一些自己的练习视频 技术方面学过一点C++和一点点Python；会那么一点点点点计算机视觉方面的东西（还在学习阶段，做不了什么东西）；有一台3D打印机，但是不会建模，打算有空学一点sw（又在乱立flag） 其他我的mbti是esfp，分享欲很强，话很多，也很好说话，非常欢迎和我聊天，没有什么雷点"},{"path":"/2024/05/23/2023Phorograph/","content":""},{"title":"搭建记录","path":"/2024/05/23/个人网站搭建记录/","content":"基于Hexo的博客网站搭建首先跟着这个教程做： hexo史上最全搭建教程-CSDN博客 教程第一部分一直到第6步结束之前都没出现问题，但是在最后的hexo deploy之后，网页加载不出来样式。于是上网找解决方案，找到了一个可以解决的： hexo + github pages搭建博客样式加载不出来_github搭建个人博客后不显示-CSDN博客 根据这个教程，我把_config.yml里的url和root对应地改正，也就是 12url: https://sirtamago.github.io/blog root: /blog/ 这样网页样式便加载出来了。 第7步和教程里边的好像不太一样，因为我这里使用了cloudflare接管rimrose.site，解析好像不太一样。（二编：这里其实是一样的，接管之后就直接用cloudflare修改DNS记录了） GitHub pages配置自定义域名利用Cloudflare全球CDN-腾讯云开发者社区-腾讯云 (tencent.com) 跟着上边的教程又加了几行GitHub的服务器地址，成功把sirtamago.github.io/blog打到rimrose.site上了，但是我其实是想搞到blog.rimrose.site上的，不过只能先这样了。 然后就又出现了一个问题，部署到rimrose.stie之后，样式又消失了。 在这之后，试了一下下图的写法，也就是把主教程里第7步里边的www改成blog，再把网站文件夹里边的CNAME改成blog.rimrose.site，就可以把pages打到blog.rimrose.site上了，如下图 继续回到样式加载不出来的问题上。 搜到了一个类似问题的issue： 部署到Github Pages之后，如果使用自定义域名的话样式会丢失 · Issue #3513 · vuejs/vitepress 但是看得有点迷糊，就又搜了点别的。看到有人说可以用检查工具看到报错，于是我在blog.rimrose.site用F12检查工具，发现了下边的问题： 比如第一行的style.css，点开之后可以看到它的地址为https://blog.rimrose.site/blog/css/style.css 这里就看出来了，文件应该是在根目录里的，并没有/blog这个文件夹。想了一下，对_config.yml里的root进行修改，也就是把一开始那里的 12url: https://sirtamago.github.io/blog root: /blog/ 改成 12url: https://sirtamago.github.io/blog root: / 尝试了一下，这样确实就可以加载css了。 成功加载css之后，再使用检查工具查看style.css的地址，可以看到它变成了https://blog.rimrose.site/css/style.css。 暂时还没有看Hexo关于配置文件的说明，但是还是想了一下上边这样做的原因： 想了一下，_config.yml里的root的值应该是相对于blog最终显示出来的那个地址来说的，而不是_config.yml里url的值。没打到自定义域名之前，url的值为https://sirtamago.github.io/blog，blog最终显示出来的地址是https://sirtamago.github.io/blog，此时root应该是sirtamago.github.io后边的/blog，所以应该这样写： 1root: /blog/ 但是打到自定义域名之后，最终显示出来那个地址变成了blog.rimrose.site，它后边没有文件夹，直接是在根目录下的，所以应该改成这样： 1root: / 在deploy时遇到了问题 Failed to connect to github.com port 443 after 21081 ms: Couldn&#39;t connect to server 参考下边这个方法解决了 解决使用git时遇到Failed to connect to github.com port 443 after 21090 ms: Couldn‘t connect to server_git couldn’t connect to server-CSDN博客 教程第二部分其他用图床时候发现一个问题，obsidian的图片链接不能含空格，但是博客园的可以加载出来。 To be continued -&gt;"},{"title":"一般情况下的阿波罗尼斯圆的方程的推导过程","path":"/2024/05/23/一般情况下的阿波罗尼斯圆的方程的推导过程/","content":"首先介绍一下什么是阿波罗尼斯圆: 已知平面上两点 $A, B$, 则所有满足 $\\frac{PA}{PB}=k$ 且不等于 $1$ 的点 $P$ 的轨迹是一个以定比 $m:n$ 内分和外分定线段 $AB$ 的两个分点的连线为直径的圆. 这个轨迹最先由古希腊数学家阿波罗尼斯发现, 故称作阿氏圆. 我翻了半天知乎, 发现没有人写阿波罗尼斯圆在最一般的情况下方程的推导, 遂作此文. 当然, 很大一部分原因是我下边写的这种推导十分麻烦, 不如以所给的两定点为 $x$ 轴来研究. 那么下边我将以最一般的情况, 用解析几何的方法来推导. 在平面直角坐标系中，已知 $A$ 的坐标为 $(x_1,y_1)$， $B$ 的坐标为 $(x_2,y_2)$ （ $A,B$ 互异），设动点 $P$ 的坐标为 $(x,y)$, 满足 $\\frac{|{PA}|}{|{PB}|}=k \\quad (k&gt;0 且 k eq1)$. 易得 \\begin{split} |PA| = \\sqrt{(x-x_1)^2+(y-y_1)^2} ,\\\\ |PB| = \\sqrt{(x-x_2)^2+(y-y_2)^2} . \\end{split}由 $\\frac{|{PA}|}{|{PB}|}=k$, 即 $|PA| = k|PB|$, 对两边平方后将上一行的两式带入得 (x-x_1)^2+(y-y_1)^2=k^2[(x-x_2)^2+(y-y_2)^2] ,展开整理后得到 (1-k^2)x^2+(1-k^2)y^2+2(k^2x_2-x_1)x+2(k^2y_2-y_1)y+x_1^2-k^2x_2^2+y_1^2-k^2y_2^2=0 ,等号两边同除以 $(1-k^2)$, 得到 x^2+y^2+\\frac{2(k^2x_2-x_1)}{1-k^2}x+\\frac{2(k^2y_2-y_1)}{1-k^2}y+\\frac{x_1^2-k^2x_2^2+y_1^2-k^2y_2^2}{1-k^2}=0 .可以配一下方，那么可以得到 \\begin{equation} otag \\begin{split} &\\ \\left(x+\\frac{k^2x_2-x_1}{1-k^2}\\right)^2+\\left(y+\\frac{k^2y_2-y_1}{1-k^2}\\right)^2 \\\\ =&\\ \\frac{(k^2x_{2}-x_{1})^2+(k^2y_{2}-y_{1})^2+(k^2-1)(x_{1}^2-k^2x_{2}^2+y_{1}^2-k^2y_{2}^2)}{(1-k^2)^2} \\\\ =&\\ \\frac{k^4x_{2}^2-2k^2x_{1}x_{2}+x_{1}^2+k^4y_{2}^2-2k^2y_{1}y_{2}+y_{1}^2+(k^2-1)x_{1}^2+(1-k^2)k^2x_{2}^2+(k^2-1)y_{1}^2+(1-k^2)k^2y_{2}^2}{(1-k^2)^2} \\\\ =&\\ \\frac{k^2 x_{1}^2+k^2x_{2}^2-2 k^2x_{1} x_{2}+k^2 y_{1}^2+k^2y_{2}^2-2k^2y_{1}y_{2}}{(1-k^2)^2} \\\\ =&\\ \\frac{k^2}{(1-k^2)^2}[(x_{1}-x_{2})^2+(y_{1}-y_{2})^2] ,\\\\ \\end{split} \\end{equation}即 (x+\\frac{k^2x_{2}-x_{1}}{1-k^2})^2+(y+\\frac{k^2y_{2}-y_{1}}{1-k^2})^2=\\frac{k^2}{(1-k^2)^2}[(x_{1}-x_{2})^2+(y_{1}-y_{2})^2] .由于 $k&gt;0$ 且 $k eq 1$, 并且 $A,B$ 两点互异, 所以等号右边的式子始终大于 $0$ , 所以这便是圆的标准方程. 这样我们就得到了阿波罗尼斯圆的方程. 实际上, 也就证明了阿波罗尼斯圆的命题. 由上式可知此情况下圆心为 \\left(\\frac{k^2x_{2}-x_{1}}{1-k^2},\\frac{k^2y_{2}-y_{1}}{1-k^2}\\right) .观察最后得到的这个式子, 不难发现 (x_1-x_2)^2+(y_1-y_2)^2=|AB|^2 .那么, 阿波罗尼斯圆的半径可以表示为 R=\\left|\\frac{k}{1-k^2}\\right|\\cdot|AB| .综上 在平面直角坐标系中, 已知 $A$ 的坐标为 $(x_1,y_1)$, $B$ 的坐标为 $(x_2,y_2)$ ($A,B$ 互异), 设动点 $P$ 的坐标为 $(x,y)$, 满足 $\\frac{|PA|}{|PB|}=k \\quad (k&gt;0且k eq 1)$, 那么点 $P$ 的轨迹是阿波罗尼斯圆, 方程为 \\left(x+\\frac{k^2x_{2}-x_{1}}{1-k^2}\\right)^2+\\left(y+\\frac{k^2y_{2}-y_{1}}{1-k^2}\\right)^2=\\left(\\frac{k}{1-k^2}|AB|\\right)^2 ,圆心为 \\left(\\frac{k^2x_{2}-x_{1}}{1-k^2},\\frac{k^2y_{2}-y_{1}}{1-k^2}\\right) ,半径为 \\left|\\frac{k}{1-k^2}\\right|\\cdot|AB| .以上.","tags":["math"]},{"title":"Hello World","path":"/2024/05/22/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment"}]